"""Vulnerability management module for Skwaq.

This module provides vulnerability management functionality for the Skwaq
vulnerability assessment copilot, including CVE tracking, vulnerability
lifecycle management, and risk assessment.
"""

import datetime
import json
import os
import re
import uuid
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set, Tuple, Union, cast

import requests

from skwaq.security.audit import AuditEventType, log_security_event, AuditLogLevel
from skwaq.utils.config import get_config
from skwaq.utils.logging import get_logger

logger = get_logger(__name__)


class VulnerabilityType(Enum):
    """Types of vulnerabilities."""
    
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    CSRF = "csrf"
    COMMAND_INJECTION = "command_injection"
    PATH_TRAVERSAL = "path_traversal"
    FILE_INCLUSION = "file_inclusion"
    INSECURE_DESERIALIZATION = "insecure_deserialization"
    XML_EXTERNAL_ENTITY = "xml_external_entity"
    OPEN_REDIRECT = "open_redirect"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    BROKEN_AUTHENTICATION = "broken_authentication"
    SENSITIVE_DATA_EXPOSURE = "sensitive_data_exposure"
    BROKEN_ACCESS_CONTROL = "broken_access_control"
    INSUFFICIENT_LOGGING = "insufficient_logging"
    USING_COMPONENTS_WITH_KNOWN_VULNERABILITIES = "using_components_with_known_vulnerabilities"
    OTHER = "other"


class VulnerabilitySeverity(Enum):
    """Severity levels for vulnerabilities."""
    
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityStatus(Enum):
    """Status of a vulnerability."""
    
    IDENTIFIED = "identified"  # Initial identification
    VERIFIED = "verified"      # Verified as a true vulnerability
    FALSE_POSITIVE = "false_positive"  # Determined to be a false positive
    ACCEPTED = "accepted"      # Accepted risk, will not be fixed
    IN_PROGRESS = "in_progress"  # Fix in progress
    FIXED = "fixed"            # Fix implemented
    CLOSED = "closed"          # Verified as fixed and closed


@dataclass
class CVEData:
    """Data for a CVE."""
    
    cve_id: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: float
    published_date: str
    last_modified_date: str
    references: List[str] = field(default_factory=list)
    cwe_ids: List[str] = field(default_factory=list)
    vulnerable_configurations: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary.
        
        Returns:
            Dictionary representation
        """
        return {
            "cve_id": self.cve_id,
            "description": self.description,
            "severity": self.severity.value,
            "cvss_score": self.cvss_score,
            "published_date": self.published_date,
            "last_modified_date": self.last_modified_date,
            "references": self.references,
            "cwe_ids": self.cwe_ids,
            "vulnerable_configurations": self.vulnerable_configurations,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "CVEData":
        """Create from dictionary.
        
        Args:
            data: Dictionary with CVE data
            
        Returns:
            CVEData object
        """
        return cls(
            cve_id=data["cve_id"],
            description=data["description"],
            severity=VulnerabilitySeverity(data["severity"]),
            cvss_score=data["cvss_score"],
            published_date=data["published_date"],
            last_modified_date=data["last_modified_date"],
            references=data.get("references", []),
            cwe_ids=data.get("cwe_ids", []),
            vulnerable_configurations=data.get("vulnerable_configurations", []),
        )


@dataclass
class CWEData:
    """Data for a CWE."""
    
    cwe_id: str
    name: str
    description: str
    extended_description: str
    likelihood: Optional[str] = None
    consequences: List[str] = field(default_factory=list)
    mitigations: List[str] = field(default_factory=list)
    related_cwe_ids: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary.
        
        Returns:
            Dictionary representation
        """
        return {
            "cwe_id": self.cwe_id,
            "name": self.name,
            "description": self.description,
            "extended_description": self.extended_description,
            "likelihood": self.likelihood,
            "consequences": self.consequences,
            "mitigations": self.mitigations,
            "related_cwe_ids": self.related_cwe_ids,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "CWEData":
        """Create from dictionary.
        
        Args:
            data: Dictionary with CWE data
            
        Returns:
            CWEData object
        """
        return cls(
            cwe_id=data["cwe_id"],
            name=data["name"],
            description=data["description"],
            extended_description=data["extended_description"],
            likelihood=data.get("likelihood"),
            consequences=data.get("consequences", []),
            mitigations=data.get("mitigations", []),
            related_cwe_ids=data.get("related_cwe_ids", []),
        )


@dataclass
class VulnerabilityFinding:
    """Vulnerability finding data."""
    
    title: str
    description: str
    vulnerability_type: VulnerabilityType
    severity: VulnerabilitySeverity
    cwe_id: Optional[str] = None
    cve_id: Optional[str] = None
    affected_components: List[str] = field(default_factory=list)
    evidence: str = ""
    remediation: str = ""
    references: List[str] = field(default_factory=list)
    status: VulnerabilityStatus = VulnerabilityStatus.IDENTIFIED
    confidence: float = 1.0  # 0.0 to 1.0
    finding_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)
    updated_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary.
        
        Returns:
            Dictionary representation
        """
        return {
            "title": self.title,
            "description": self.description,
            "vulnerability_type": self.vulnerability_type.value,
            "severity": self.severity.value,
            "cwe_id": self.cwe_id,
            "cve_id": self.cve_id,
            "affected_components": self.affected_components,
            "evidence": self.evidence,
            "remediation": self.remediation,
            "references": self.references,
            "status": self.status.value,
            "confidence": self.confidence,
            "finding_id": self.finding_id,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "metadata": self.metadata,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "VulnerabilityFinding":
        """Create from dictionary.
        
        Args:
            data: Dictionary with finding data
            
        Returns:
            VulnerabilityFinding object
        """
        return cls(
            title=data["title"],
            description=data["description"],
            vulnerability_type=VulnerabilityType(data["vulnerability_type"]),
            severity=VulnerabilitySeverity(data["severity"]),
            cwe_id=data.get("cwe_id"),
            cve_id=data.get("cve_id"),
            affected_components=data.get("affected_components", []),
            evidence=data.get("evidence", ""),
            remediation=data.get("remediation", ""),
            references=data.get("references", []),
            status=VulnerabilityStatus(data.get("status", "identified")),
            confidence=data.get("confidence", 1.0),
            finding_id=data.get("finding_id", str(uuid.uuid4())),
            created_at=datetime.datetime.fromisoformat(data["created_at"]) if "created_at" in data else datetime.datetime.utcnow(),
            updated_at=datetime.datetime.fromisoformat(data["updated_at"]) if "updated_at" in data else datetime.datetime.utcnow(),
            metadata=data.get("metadata", {}),
        )


@dataclass
class RemediationAction:
    """Remediation action for a vulnerability."""
    
    description: str
    action_type: str  # 'code_fix', 'configuration_change', 'dependency_update', etc.
    assigned_to: Optional[str] = None
    due_date: Optional[datetime.datetime] = None
    status: str = "open"  # 'open', 'in_progress', 'completed', 'rejected'
    completed_at: Optional[datetime.datetime] = None
    notes: str = ""
    action_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    created_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)
    updated_at: datetime.datetime = field(default_factory=datetime.datetime.utcnow)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary.
        
        Returns:
            Dictionary representation
        """
        return {
            "description": self.description,
            "action_type": self.action_type,
            "assigned_to": self.assigned_to,
            "due_date": self.due_date.isoformat() if self.due_date else None,
            "status": self.status,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "notes": self.notes,
            "action_id": self.action_id,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RemediationAction":
        """Create from dictionary.
        
        Args:
            data: Dictionary with action data
            
        Returns:
            RemediationAction object
        """
        return cls(
            description=data["description"],
            action_type=data["action_type"],
            assigned_to=data.get("assigned_to"),
            due_date=datetime.datetime.fromisoformat(data["due_date"]) if data.get("due_date") else None,
            status=data.get("status", "open"),
            completed_at=datetime.datetime.fromisoformat(data["completed_at"]) if data.get("completed_at") else None,
            notes=data.get("notes", ""),
            action_id=data.get("action_id", str(uuid.uuid4())),
            created_at=datetime.datetime.fromisoformat(data["created_at"]) if "created_at" in data else datetime.datetime.utcnow(),
            updated_at=datetime.datetime.fromisoformat(data["updated_at"]) if "updated_at" in data else datetime.datetime.utcnow(),
        )


class VulnerabilityManager:
    """Manager for vulnerability management."""
    
    _instance = None
    
    def __new__(cls) -> 'VulnerabilityManager':
        """Create a singleton instance.
        
        Returns:
            Singleton instance
        """
        if cls._instance is None:
            cls._instance = super(VulnerabilityManager, cls).__new__(cls)
            cls._instance._initialized = False
        return cls._instance
    
    def __init__(self):
        """Initialize the vulnerability manager."""
        if self._initialized:
            return
            
        self._initialized = True
        self._findings: Dict[str, VulnerabilityFinding] = {}
        self._remediation_actions: Dict[str, List[RemediationAction]] = {}
        self._cve_cache: Dict[str, CVEData] = {}
        self._cwe_cache: Dict[str, CWEData] = {}
        self._nvd_api_key = get_config().get("security.nvd_api_key")
        self._findings_dir = Path(get_config().get("security.findings_dir", "~/.skwaq/findings")).expanduser()
        
        # Create findings directory
        os.makedirs(self._findings_dir, exist_ok=True)
        
        # Load cached CVE and CWE data
        self._load_cve_cache()
        self._load_cwe_cache()
    
    def _load_cve_cache(self) -> None:
        """Load cached CVE data."""
        cache_file = self._findings_dir / "cve_cache.json"
        
        if not cache_file.exists():
            return
            
        try:
            with open(cache_file, "r") as f:
                cve_data = json.load(f)
                
            for cve_id, data in cve_data.items():
                self._cve_cache[cve_id] = CVEData.from_dict(data)
                
            logger.info(f"Loaded {len(self._cve_cache)} CVEs from cache")
            
        except Exception as e:
            logger.error(f"Error loading CVE cache: {e}")
    
    def _save_cve_cache(self) -> None:
        """Save cached CVE data."""
        cache_file = self._findings_dir / "cve_cache.json"
        
        try:
            cve_data = {cve_id: cve.to_dict() for cve_id, cve in self._cve_cache.items()}
            
            with open(cache_file, "w") as f:
                json.dump(cve_data, f, indent=2)
                
            logger.info(f"Saved {len(self._cve_cache)} CVEs to cache")
            
        except Exception as e:
            logger.error(f"Error saving CVE cache: {e}")
    
    def _load_cwe_cache(self) -> None:
        """Load cached CWE data."""
        cache_file = self._findings_dir / "cwe_cache.json"
        
        if not cache_file.exists():
            return
            
        try:
            with open(cache_file, "r") as f:
                cwe_data = json.load(f)
                
            for cwe_id, data in cwe_data.items():
                self._cwe_cache[cwe_id] = CWEData.from_dict(data)
                
            logger.info(f"Loaded {len(self._cwe_cache)} CWEs from cache")
            
        except Exception as e:
            logger.error(f"Error loading CWE cache: {e}")
    
    def _save_cwe_cache(self) -> None:
        """Save cached CWE data."""
        cache_file = self._findings_dir / "cwe_cache.json"
        
        try:
            cwe_data = {cwe_id: cwe.to_dict() for cwe_id, cwe in self._cwe_cache.items()}
            
            with open(cache_file, "w") as f:
                json.dump(cwe_data, f, indent=2)
                
            logger.info(f"Saved {len(self._cwe_cache)} CWEs to cache")
            
        except Exception as e:
            logger.error(f"Error saving CWE cache: {e}")
    
    def add_finding(self, finding: VulnerabilityFinding) -> str:
        """Add a vulnerability finding.
        
        Args:
            finding: Vulnerability finding
            
        Returns:
            Finding ID
        """
        # Set created_at and updated_at
        finding.created_at = datetime.datetime.utcnow()
        finding.updated_at = datetime.datetime.utcnow()
        
        # Set finding ID if not set
        if not finding.finding_id:
            finding.finding_id = str(uuid.uuid4())
            
        # Add to findings
        self._findings[finding.finding_id] = finding
        
        # Initialize empty remediation actions list
        self._remediation_actions[finding.finding_id] = []
        
        # Save the finding
        self._save_finding(finding)
        
        # Log the finding
        log_security_event(
            event_type=AuditEventType.SECURITY_ALERT,
            component="VulnerabilityManager",
            message=f"Added vulnerability finding: {finding.title}",
            details={
                "finding_id": finding.finding_id,
                "vulnerability_type": finding.vulnerability_type.value,
                "severity": finding.severity.value,
                "cwe_id": finding.cwe_id,
            },
            level=AuditLogLevel.SECURITY,
        )
        
        return finding.finding_id
    
    def update_finding(self, finding_id: str, updates: Dict[str, Any]) -> bool:
        """Update a vulnerability finding.
        
        Args:
            finding_id: Finding ID
            updates: Dictionary of updates
            
        Returns:
            True if finding was updated, False if not found
        """
        if finding_id not in self._findings:
            return False
            
        finding = self._findings[finding_id]
        
        # Apply updates
        for key, value in updates.items():
            if hasattr(finding, key):
                # Handle enum values
                if key == "vulnerability_type" and isinstance(value, str):
                    setattr(finding, key, VulnerabilityType(value))
                elif key == "severity" and isinstance(value, str):
                    setattr(finding, key, VulnerabilitySeverity(value))
                elif key == "status" and isinstance(value, str):
                    setattr(finding, key, VulnerabilityStatus(value))
                else:
                    setattr(finding, key, value)
        
        # Update updated_at
        finding.updated_at = datetime.datetime.utcnow()
        
        # Save the finding
        self._save_finding(finding)
        
        # Log the update
        log_security_event(
            event_type=AuditEventType.DATA_MODIFIED,
            component="VulnerabilityManager",
            message=f"Updated vulnerability finding: {finding.title}",
            details={
                "finding_id": finding.finding_id,
                "updates": list(updates.keys()),
            },
            level=AuditLogLevel.INFO,
        )
        
        return True
    
    def get_finding(self, finding_id: str) -> Optional[VulnerabilityFinding]:
        """Get a vulnerability finding.
        
        Args:
            finding_id: Finding ID
            
        Returns:
            VulnerabilityFinding if found, None otherwise
        """
        if finding_id in self._findings:
            return self._findings[finding_id]
            
        # Try to load from file
        finding = self._load_finding(finding_id)
        if finding:
            # Cache for future use
            self._findings[finding_id] = finding
            return finding
            
        return None
    
    def get_findings(
        self,
        vulnerability_type: Optional[VulnerabilityType] = None,
        severity: Optional[VulnerabilitySeverity] = None,
        status: Optional[VulnerabilityStatus] = None,
        cwe_id: Optional[str] = None,
        confidence_threshold: Optional[float] = None,
    ) -> List[VulnerabilityFinding]:
        """Get vulnerability findings.
        
        Args:
            vulnerability_type: Optional vulnerability type to filter by
            severity: Optional severity to filter by
            status: Optional status to filter by
            cwe_id: Optional CWE ID to filter by
            confidence_threshold: Optional confidence threshold
            
        Returns:
            List of vulnerability findings
        """
        # Load all findings if not cached
        if not self._findings:
            self._load_all_findings()
            
        findings = list(self._findings.values())
        
        # Apply filters
        if vulnerability_type:
            findings = [f for f in findings if f.vulnerability_type == vulnerability_type]
            
        if severity:
            findings = [f for f in findings if f.severity == severity]
            
        if status:
            findings = [f for f in findings if f.status == status]
            
        if cwe_id:
            findings = [f for f in findings if f.cwe_id == cwe_id]
            
        if confidence_threshold is not None:
            findings = [f for f in findings if f.confidence >= confidence_threshold]
            
        return findings
    
    def delete_finding(self, finding_id: str) -> bool:
        """Delete a vulnerability finding.
        
        Args:
            finding_id: Finding ID
            
        Returns:
            True if finding was deleted, False if not found
        """
        if finding_id not in self._findings:
            finding = self._load_finding(finding_id)
            if not finding:
                return False
                
        # Log the deletion
        log_security_event(
            event_type=AuditEventType.DATA_DELETED,
            component="VulnerabilityManager",
            message=f"Deleted vulnerability finding: {self._findings[finding_id].title}",
            details={
                "finding_id": finding_id,
            },
            level=AuditLogLevel.INFO,
        )
        
        # Delete from memory
        if finding_id in self._findings:
            finding = self._findings.pop(finding_id)
            
        # Delete remediation actions
        if finding_id in self._remediation_actions:
            del self._remediation_actions[finding_id]
            
        # Delete from disk
        finding_file = self._findings_dir / f"{finding_id}.json"
        if finding_file.exists():
            os.remove(finding_file)
            
        return True
    
    def add_remediation_action(
        self, finding_id: str, action: RemediationAction
    ) -> Optional[str]:
        """Add a remediation action for a vulnerability.
        
        Args:
            finding_id: Finding ID
            action: Remediation action
            
        Returns:
            Action ID if successful, None if finding not found
        """
        finding = self.get_finding(finding_id)
        if not finding:
            return None
            
        # Set action ID if not set
        if not action.action_id:
            action.action_id = str(uuid.uuid4())
            
        # Set created_at and updated_at
        action.created_at = datetime.datetime.utcnow()
        action.updated_at = datetime.datetime.utcnow()
        
        # Add to remediation actions
        if finding_id not in self._remediation_actions:
            self._remediation_actions[finding_id] = []
            
        self._remediation_actions[finding_id].append(action)
        
        # Save the remediation action
        self._save_remediation_action(finding_id, action)
        
        # Update finding status if necessary
        if finding.status == VulnerabilityStatus.IDENTIFIED:
            self.update_finding(finding_id, {"status": VulnerabilityStatus.IN_PROGRESS})
            
        # Log the action
        log_security_event(
            event_type=AuditEventType.DATA_MODIFIED,
            component="VulnerabilityManager",
            message=f"Added remediation action for finding: {finding.title}",
            details={
                "finding_id": finding_id,
                "action_id": action.action_id,
                "action_type": action.action_type,
                "assigned_to": action.assigned_to,
            },
            level=AuditLogLevel.INFO,
        )
        
        return action.action_id
    
    def update_remediation_action(
        self, finding_id: str, action_id: str, updates: Dict[str, Any]
    ) -> bool:
        """Update a remediation action.
        
        Args:
            finding_id: Finding ID
            action_id: Action ID
            updates: Dictionary of updates
            
        Returns:
            True if action was updated, False if not found
        """
        if finding_id not in self._remediation_actions:
            # Try to load remediation actions
            self._load_remediation_actions(finding_id)
            if finding_id not in self._remediation_actions:
                return False
                
        # Find the action
        for i, action in enumerate(self._remediation_actions[finding_id]):
            if action.action_id == action_id:
                # Apply updates
                for key, value in updates.items():
                    if hasattr(action, key):
                        setattr(action, key, value)
                
                # Update updated_at
                action.updated_at = datetime.datetime.utcnow()
                
                # Save the action
                self._save_remediation_action(finding_id, action)
                
                # Check if action is completed
                if action.status == "completed" and not action.completed_at:
                    action.completed_at = datetime.datetime.utcnow()
                    
                # Check if all actions are completed
                if all(a.status == "completed" for a in self._remediation_actions[finding_id]):
                    # Update finding status to FIXED
                    finding = self.get_finding(finding_id)
                    if finding and finding.status != VulnerabilityStatus.FIXED:
                        self.update_finding(finding_id, {"status": VulnerabilityStatus.FIXED})
                
                # Log the update
                log_security_event(
                    event_type=AuditEventType.DATA_MODIFIED,
                    component="VulnerabilityManager",
                    message=f"Updated remediation action",
                    details={
                        "finding_id": finding_id,
                        "action_id": action_id,
                        "updates": list(updates.keys()),
                    },
                    level=AuditLogLevel.INFO,
                )
                
                return True
                
        return False
    
    def get_remediation_actions(self, finding_id: str) -> List[RemediationAction]:
        """Get remediation actions for a vulnerability.
        
        Args:
            finding_id: Finding ID
            
        Returns:
            List of remediation actions
        """
        if finding_id not in self._remediation_actions:
            # Try to load remediation actions
            self._load_remediation_actions(finding_id)
            
        return self._remediation_actions.get(finding_id, [])
    
    def get_cve_data(self, cve_id: str) -> Optional[CVEData]:
        """Get data for a CVE.
        
        Args:
            cve_id: CVE ID
            
        Returns:
            CVEData if found, None otherwise
        """
        # Check cache
        if cve_id in self._cve_cache:
            return self._cve_cache[cve_id]
            
        # Validate CVE ID format
        if not re.match(r"^CVE-\d{4}-\d{4,}$", cve_id):
            logger.error(f"Invalid CVE ID format: {cve_id}")
            return None
            
        # Fetch from NVD API
        try:
            url = f"https://services.nvd.nist.gov/rest/json/cve/1.0/{cve_id}"
            headers = {}
            
            if self._nvd_api_key:
                headers["apiKey"] = self._nvd_api_key
                
            response = requests.get(url, headers=headers)
            
            if response.status_code != 200:
                logger.error(f"Failed to fetch CVE data: {response.status_code} {response.text}")
                return None
                
            data = response.json()
            
            if "result" not in data:
                logger.error(f"Invalid response from NVD API: {data}")
                return None
                
            cve_item = data["result"]["CVE_Items"][0]
            
            # Extract CVE data
            description = cve_item["cve"]["description"]["description_data"][0]["value"]
            
            # Extract CVSS data
            cvss_data = cve_item.get("impact", {}).get("baseMetricV3", {}).get("cvssV3", {})
            if not cvss_data:
                cvss_data = cve_item.get("impact", {}).get("baseMetricV2", {}).get("cvssV2", {})
                
            cvss_score = float(cvss_data.get("baseScore", 0))
            
            # Determine severity
            severity_str = cvss_data.get("baseSeverity", "").lower()
            if severity_str == "critical":
                severity = VulnerabilitySeverity.CRITICAL
            elif severity_str == "high":
                severity = VulnerabilitySeverity.HIGH
            elif severity_str == "medium":
                severity = VulnerabilitySeverity.MEDIUM
            elif severity_str == "low":
                severity = VulnerabilitySeverity.LOW
            else:
                severity = VulnerabilitySeverity.INFO
                
            # Extract dates
            published_date = cve_item["publishedDate"]
            last_modified_date = cve_item["lastModifiedDate"]
            
            # Extract references
            references = [
                ref["url"]
                for ref in cve_item["cve"]["references"]["reference_data"]
            ]
            
            # Extract CWE IDs
            cwe_ids = [
                weak["value"]
                for weak in cve_item["cve"]["problemtype"]["problemtype_data"][0]["description"]
                if weak["value"].startswith("CWE-")
            ]
            
            # Extract vulnerable configurations
            configs = []
            for node in cve_item.get("configurations", {}).get("nodes", []):
                for cpe in node.get("cpe_match", []):
                    configs.append(cpe.get("cpe23Uri", ""))
                    
            # Create CVE data
            cve_data = CVEData(
                cve_id=cve_id,
                description=description,
                severity=severity,
                cvss_score=cvss_score,
                published_date=published_date,
                last_modified_date=last_modified_date,
                references=references,
                cwe_ids=cwe_ids,
                vulnerable_configurations=configs,
            )
            
            # Cache the data
            self._cve_cache[cve_id] = cve_data
            self._save_cve_cache()
            
            return cve_data
            
        except Exception as e:
            logger.error(f"Error fetching CVE data: {e}")
            return None
    
    def get_cwe_data(self, cwe_id: str) -> Optional[CWEData]:
        """Get data for a CWE.
        
        Args:
            cwe_id: CWE ID
            
        Returns:
            CWEData if found, None otherwise
        """
        # Check cache
        if cwe_id in self._cwe_cache:
            return self._cwe_cache[cwe_id]
            
        # Validate CWE ID format
        if not re.match(r"^CWE-\d+$", cwe_id):
            logger.error(f"Invalid CWE ID format: {cwe_id}")
            return None
            
        # TODO: Implement fetching CWE data from the CWE database
        # This would require parsing the XML or using a third-party API
        
        return None
    
    def correlate_with_cve(self, finding: VulnerabilityFinding) -> List[CVEData]:
        """Correlate a vulnerability finding with CVEs.
        
        Args:
            finding: Vulnerability finding
            
        Returns:
            List of related CVE data
        """
        related_cves = []
        
        # If finding already has a CVE ID, get data for it
        if finding.cve_id:
            cve_data = self.get_cve_data(finding.cve_id)
            if cve_data:
                related_cves.append(cve_data)
                
        # If finding has a CWE ID, get CVEs related to that CWE
        if finding.cwe_id:
            # TODO: Implement fetching CVEs related to a CWE
            # This would require a more comprehensive API or database
            pass
            
        return related_cves
    
    def generate_report(
        self,
        findings: Optional[List[VulnerabilityFinding]] = None,
        include_remediation: bool = True,
        include_cve_data: bool = True,
    ) -> Dict[str, Any]:
        """Generate a vulnerability report.
        
        Args:
            findings: Optional list of findings to include
            include_remediation: Whether to include remediation actions
            include_cve_data: Whether to include CVE data
            
        Returns:
            Report data as a dictionary
        """
        # Get all findings if not specified
        if findings is None:
            findings = self.get_findings()
            
        # Count findings by severity
        severity_counts = {severity.value: 0 for severity in VulnerabilitySeverity}
        for finding in findings:
            severity_counts[finding.severity.value] += 1
            
        # Count findings by status
        status_counts = {status.value: 0 for status in VulnerabilityStatus}
        for finding in findings:
            status_counts[finding.status.value] += 1
            
        # Count findings by vulnerability type
        type_counts = {vuln_type.value: 0 for vuln_type in VulnerabilityType}
        for finding in findings:
            type_counts[finding.vulnerability_type.value] += 1
            
        # Calculate risk score (weighted by severity)
        severity_weights = {
            VulnerabilitySeverity.CRITICAL.value: 10,
            VulnerabilitySeverity.HIGH.value: 7,
            VulnerabilitySeverity.MEDIUM.value: 4,
            VulnerabilitySeverity.LOW.value: 1,
            VulnerabilitySeverity.INFO.value: 0,
        }
        
        total_findings = len(findings)
        weighted_sum = sum(
            severity_weights[finding.severity.value] for finding in findings
        )
        
        risk_score = 0
        if total_findings > 0:
            risk_score = weighted_sum / total_findings * 10  # Scale to 0-100
            
        # Prepare findings data
        findings_data = []
        for finding in findings:
            finding_data = finding.to_dict()
            
            # Add remediation actions
            if include_remediation:
                remediation_actions = self.get_remediation_actions(finding.finding_id)
                finding_data["remediation_actions"] = [
                    action.to_dict() for action in remediation_actions
                ]
                
            # Add CVE data
            if include_cve_data and finding.cve_id:
                cve_data = self.get_cve_data(finding.cve_id)
                if cve_data:
                    finding_data["cve_data"] = cve_data.to_dict()
                    
            findings_data.append(finding_data)
            
        # Build the report
        report = {
            "title": "Vulnerability Assessment Report",
            "date": datetime.datetime.utcnow().isoformat(),
            "summary": {
                "total_findings": total_findings,
                "risk_score": round(risk_score, 1),
                "severity_distribution": severity_counts,
                "status_distribution": status_counts,
                "type_distribution": type_counts,
            },
            "findings": findings_data,
        }
        
        return report
    
    def _save_finding(self, finding: VulnerabilityFinding) -> None:
        """Save a vulnerability finding to disk.
        
        Args:
            finding: Vulnerability finding
        """
        finding_file = self._findings_dir / f"{finding.finding_id}.json"
        
        try:
            with open(finding_file, "w") as f:
                json.dump(finding.to_dict(), f, indent=2)
                
        except Exception as e:
            logger.error(f"Error saving finding: {e}")
    
    def _load_finding(self, finding_id: str) -> Optional[VulnerabilityFinding]:
        """Load a vulnerability finding from disk.
        
        Args:
            finding_id: Finding ID
            
        Returns:
            VulnerabilityFinding if found, None otherwise
        """
        finding_file = self._findings_dir / f"{finding_id}.json"
        
        if not finding_file.exists():
            return None
            
        try:
            with open(finding_file, "r") as f:
                finding_data = json.load(f)
                
            return VulnerabilityFinding.from_dict(finding_data)
            
        except Exception as e:
            logger.error(f"Error loading finding {finding_id}: {e}")
            return None
    
    def _load_all_findings(self) -> None:
        """Load all vulnerability findings from disk."""
        try:
            for finding_file in self._findings_dir.glob("*.json"):
                if finding_file.name.startswith("cve_") or finding_file.name.startswith("cwe_"):
                    continue
                    
                finding_id = finding_file.stem
                finding = self._load_finding(finding_id)
                
                if finding:
                    self._findings[finding_id] = finding
                    
            logger.info(f"Loaded {len(self._findings)} findings from disk")
            
        except Exception as e:
            logger.error(f"Error loading findings: {e}")
    
    def _save_remediation_action(
        self, finding_id: str, action: RemediationAction
    ) -> None:
        """Save a remediation action to disk.
        
        Args:
            finding_id: Finding ID
            action: Remediation action
        """
        remediation_dir = self._findings_dir / finding_id
        os.makedirs(remediation_dir, exist_ok=True)
        
        action_file = remediation_dir / f"{action.action_id}.json"
        
        try:
            with open(action_file, "w") as f:
                json.dump(action.to_dict(), f, indent=2)
                
        except Exception as e:
            logger.error(f"Error saving remediation action: {e}")
    
    def _load_remediation_actions(self, finding_id: str) -> None:
        """Load remediation actions for a finding from disk.
        
        Args:
            finding_id: Finding ID
        """
        remediation_dir = self._findings_dir / finding_id
        
        if not remediation_dir.exists():
            self._remediation_actions[finding_id] = []
            return
            
        try:
            actions = []
            
            for action_file in remediation_dir.glob("*.json"):
                try:
                    with open(action_file, "r") as f:
                        action_data = json.load(f)
                        
                    action = RemediationAction.from_dict(action_data)
                    actions.append(action)
                    
                except Exception as e:
                    logger.error(f"Error loading remediation action {action_file}: {e}")
                    
            self._remediation_actions[finding_id] = actions
            
            logger.debug(
                f"Loaded {len(actions)} remediation actions for finding {finding_id}"
            )
            
        except Exception as e:
            logger.error(f"Error loading remediation actions for finding {finding_id}: {e}")
            self._remediation_actions[finding_id] = []


def get_vulnerability_manager() -> VulnerabilityManager:
    """Get the global vulnerability manager instance.
    
    Returns:
        VulnerabilityManager instance
    """
    return VulnerabilityManager()


# Helper functions for common vulnerability management tasks

def add_vulnerability(
    title: str,
    description: str,
    vulnerability_type: Union[str, VulnerabilityType],
    severity: Union[str, VulnerabilitySeverity],
    cwe_id: Optional[str] = None,
    evidence: str = "",
    remediation: str = "",
) -> str:
    """Add a vulnerability finding.
    
    Args:
        title: Finding title
        description: Finding description
        vulnerability_type: Vulnerability type
        severity: Severity level
        cwe_id: Optional CWE ID
        evidence: Optional evidence
        remediation: Optional remediation guidance
        
    Returns:
        Finding ID
    """
    # Convert string enums to enum values
    if isinstance(vulnerability_type, str):
        vulnerability_type = VulnerabilityType(vulnerability_type)
        
    if isinstance(severity, str):
        severity = VulnerabilitySeverity(severity)
        
    # Create the finding
    finding = VulnerabilityFinding(
        title=title,
        description=description,
        vulnerability_type=vulnerability_type,
        severity=severity,
        cwe_id=cwe_id,
        evidence=evidence,
        remediation=remediation,
        status=VulnerabilityStatus.IDENTIFIED,
    )
    
    # Add the finding
    vulnerability_manager = get_vulnerability_manager()
    return vulnerability_manager.add_finding(finding)


def add_remediation(
    finding_id: str,
    description: str,
    action_type: str,
    assigned_to: Optional[str] = None,
) -> Optional[str]:
    """Add a remediation action for a vulnerability.
    
    Args:
        finding_id: Finding ID
        description: Action description
        action_type: Action type
        assigned_to: Optional person assigned to the action
        
    Returns:
        Action ID if successful, None if finding not found
    """
    # Create the action
    action = RemediationAction(
        description=description,
        action_type=action_type,
        assigned_to=assigned_to,
        status="open",
    )
    
    # Add the action
    vulnerability_manager = get_vulnerability_manager()
    return vulnerability_manager.add_remediation_action(finding_id, action)


def complete_remediation(finding_id: str, action_id: str, notes: str = "") -> bool:
    """Mark a remediation action as completed.
    
    Args:
        finding_id: Finding ID
        action_id: Action ID
        notes: Optional completion notes
        
    Returns:
        True if action was updated, False if not found
    """
    vulnerability_manager = get_vulnerability_manager()
    return vulnerability_manager.update_remediation_action(
        finding_id,
        action_id,
        {
            "status": "completed",
            "completed_at": datetime.datetime.utcnow(),
            "notes": notes,
        },
    )


def get_vulnerability_report() -> Dict[str, Any]:
    """Generate a vulnerability report for all findings.
    
    Returns:
        Vulnerability report as a dictionary
    """
    vulnerability_manager = get_vulnerability_manager()
    return vulnerability_manager.generate_report()