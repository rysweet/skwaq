"""Vulnerability research workflow for the Skwaq vulnerability assessment copilot.

This module implements the comprehensive vulnerability research workflow,
which coordinates multiple agents to analyze a codebase for security vulnerabilities.
"""

from typing import Dict, List, Any, Optional, AsyncGenerator, Set
import asyncio
import json
from datetime import datetime

from autogen_core.agent import Agent
from autogen_core.event import BaseEvent, Event, EventHook

from .base import Workflow
from ..agents.vulnerability_agents import (
    SkwaqAgent, 
    KnowledgeRetrievalEvent, 
    VulnerabilityResearchAgent
)
from ..db.neo4j_connector import get_connector
from ..utils.logging import get_logger

logger = get_logger(__name__)


class VulnerabilityFindingEvent(BaseEvent):
    """Event for vulnerability findings."""
    
    def __init__(
        self,
        sender: str,
        title: str,
        description: str,
        severity: str,
        cwe_id: Optional[str] = None,
        file_path: Optional[str] = None,
        line_numbers: Optional[List[int]] = None,
        recommendations: Optional[str] = None,
        target: Optional[str] = None,
    ):
        super().__init__(
            sender=sender,
            target=target,
            title=title,
            description=description,
            severity=severity,
            cwe_id=cwe_id,
            file_path=file_path,
            line_numbers=line_numbers or [],
            recommendations=recommendations or "",
        )


class VulnerabilityResearchWorkflow(Workflow):
    """Comprehensive vulnerability research workflow.
    
    This workflow coordinates multiple agents to analyze a codebase for
    security vulnerabilities, using a structured approach that combines
    static analysis, knowledge retrieval, and AI-driven reasoning.
    """
    
    def __init__(
        self,
        repository_id: int,
        focus_areas: Optional[List[str]] = None,
    ):
        """Initialize the vulnerability research workflow.
        
        Args:
            repository_id: ID of the repository to analyze
            focus_areas: Optional list of vulnerability categories to focus on
        """
        if not repository_id:
            raise ValueError("Repository ID is required for vulnerability research workflow")
            
        super().__init__(
            name="Vulnerability Research",
            description="Comprehensive vulnerability assessment of a codebase",
            repository_id=repository_id,
        )
        
        self.focus_areas = focus_areas or [
            "Injection",
            "Authentication",
            "Authorization",
            "Sensitive Data Exposure",
            "Security Misconfiguration",
            "Input Validation",
            "Error Handling",
            "Cryptographic Issues",
        ]
        
        self.findings = []
    
    async def setup(self) -> None:
        """Set up the vulnerability research workflow."""
        await super().setup()
        
        # Set up event handlers
        self.agents["vulnerability_research"].register_event_hook(
            VulnerabilityFindingEvent,
            self._on_vulnerability_found
        )
        
        # Create the vulnerability research specialized agent
        self.agents["vuln_researcher"] = VulnerabilityResearchAgent(
            repository_id=self.repository_id,
            investigation_id=self.investigation_id,
        )
        
        logger.info("Set up Vulnerability Research workflow")
    
    async def _on_vulnerability_found(self, event: VulnerabilityFindingEvent) -> None:
        """Handle vulnerability finding events.
        
        Args:
            event: The vulnerability finding event
        """
        # Record the finding
        finding_id = await self._record_finding(
            title=event.title,
            description=event.description,
            severity=event.severity,
            cwe_id=event.cwe_id,
            file_path=event.file_path,
            line_numbers=event.line_numbers,
            recommendations=event.recommendations,
        )
        
        # Add to our list of findings
        self.findings.append({
            "id": finding_id,
            "title": event.title,
            "severity": event.severity,
            "cwe_id": event.cwe_id,
            "file_path": event.file_path,
        })
        
        logger.info(f"Recorded vulnerability finding: {event.title} ({event.severity})")
    
    async def run(self) -> AsyncGenerator[Dict[str, Any], None]:
        """Run the vulnerability research workflow.
        
        Yields:
            Progress updates and findings from the vulnerability research process
        """
        logger.info("Starting vulnerability research workflow")
        yield {"status": "starting", "message": "Starting vulnerability research workflow"}
        
        # Get repository information
        repo_info = self._get_repository_info()
        if not repo_info:
            yield {"status": "error", "message": "Failed to retrieve repository information"}
            return
        
        yield {
            "status": "processing",
            "message": f"Analyzing repository: {repo_info.get('name')}",
            "repository": repo_info,
        }
        
        # Phase 1: Initial repository assessment
        yield {"status": "phase", "phase": 1, "message": "Performing initial repository assessment"}
        assessment = await self._perform_initial_assessment(repo_info)
        
        yield {
            "status": "assessment_complete",
            "assessment": assessment,
        }
        
        # Phase 2: Focus area analysis
        for i, focus_area in enumerate(self.focus_areas):
            yield {
                "status": "phase",
                "phase": 2,
                "sub_phase": i + 1,
                "message": f"Analyzing focus area: {focus_area}",
                "focus_area": focus_area,
            }
            
            await self._analyze_focus_area(focus_area, repo_info)
            
            yield {
                "status": "focus_area_complete",
                "focus_area": focus_area,
                "findings_count": len(self.findings),
            }
        
        # Phase 3: Consolidation and reporting
        yield {"status": "phase", "phase": 3, "message": "Consolidating findings and generating report"}
        
        # Generate final report
        report = await self._generate_report()
        
        yield {
            "status": "completed",
            "message": "Vulnerability research complete",
            "findings_count": len(self.findings),
            "report": report,
        }
    
    def _get_repository_info(self) -> Dict[str, Any]:
        """Get information about the repository being analyzed.
        
        Returns:
            Dictionary with repository information
        """
        query = """
        MATCH (r:Repository)
        WHERE id(r) = $repo_id
        RETURN r.name AS name, r.path AS path, r.summary AS summary,
               r.ingest_timestamp AS ingest_timestamp
        """
        
        results = self.connector.run_query(query, {"repo_id": self.repository_id})
        if not results:
            logger.error(f"Repository with ID {self.repository_id} not found")
            return None
        
        # Get file statistics
        stats_query = """
        MATCH (r:Repository)-[:HAS_FILE]->(f:File)
        WHERE id(r) = $repo_id
        WITH f.language AS language, count(f) AS count
        WHERE language IS NOT NULL
        RETURN language, count
        ORDER BY count DESC
        """
        
        stats_results = self.connector.run_query(stats_query, {"repo_id": self.repository_id})
        languages = {result["language"]: result["count"] for result in stats_results}
        
        # Get directory count
        dir_query = """
        MATCH (r:Repository)-[:HAS_DIRECTORY]->(d:Directory)
        WHERE id(r) = $repo_id
        RETURN count(d) AS dir_count
        """
        
        dir_results = self.connector.run_query(dir_query, {"repo_id": self.repository_id})
        dir_count = dir_results[0]["dir_count"] if dir_results else 0
        
        # Combine all information
        repo_info = results[0]
        repo_info["languages"] = languages
        repo_info["directory_count"] = dir_count
        repo_info["file_count"] = sum(languages.values())
        
        return repo_info
    
    async def _perform_initial_assessment(self, repo_info: Dict[str, Any]) -> Dict[str, Any]:
        """Perform initial assessment of the repository.
        
        Args:
            repo_info: Repository information
            
        Returns:
            Dictionary with assessment results
        """
        logger.info(f"Performing initial assessment of repository: {repo_info.get('name')}")
        
        # Get repository summary
        summary = repo_info.get("summary", "No summary available")
        
        # Get key security-related files
        security_files = await self._find_security_relevant_files()
        
        # Generate initial assessment using the vulnerability research agent
        assessment_prompt = f"""Perform an initial security assessment of this codebase based on the following information:

Repository: {repo_info.get('name')}
Languages: {', '.join([f"{lang} ({count})" for lang, count in repo_info.get('languages', {}).items()])}
Summary: {summary}

Security-relevant files found:
{self._format_file_list(security_files)}

Provide a brief assessment focusing on:
1. Potential security categories of concern based on the codebase characteristics
2. Likely areas to focus vulnerability research given the repository structure
3. Initial security indicators (positive or negative) visible from the high-level overview
"""
        
        # Get the assessment from the vulnerability research agent
        assessment_result = await self.agents["vuln_researcher"].analyze_text(assessment_prompt)
        
        # Record the assessment in the investigation
        if self.investigation_id:
            self.connector.run_query(
                "MATCH (i:Investigation) WHERE id(i) = $id "
                "CREATE (a:Assessment {text: $assessment, timestamp: $timestamp}) "
                "CREATE (i)-[:HAS_ASSESSMENT]->(a)",
                {
                    "id": self.investigation_id,
                    "assessment": assessment_result,
                    "timestamp": datetime.utcnow().isoformat(),
                },
            )
        
        return {
            "summary": summary,
            "security_files_count": len(security_files),
            "assessment": assessment_result,
        }
    
    async def _find_security_relevant_files(self) -> List[Dict[str, Any]]:
        """Find security-relevant files in the repository.
        
        Returns:
            List of security-relevant files
        """
        # Patterns of security-relevant file names
        security_patterns = [
            "%security%", "%auth%", "%login%", "%password%", "%crypt%",
            "%config%", "%secret%", "%cert%", "%key%", "%permission%",
            "%token%", "%jwt%", "%oauth%", "%hash%", "%encrypt%",
            "%vulnerability%", "%secure%"
        ]
        
        # Construct the query with pattern matching
        conditions = []
        for pattern in security_patterns:
            conditions.append(f"f.name CONTAINS '{pattern}' OR f.path CONTAINS '{pattern}'")
        
        where_clause = " OR ".join(conditions)
        
        query = f"""
        MATCH (r:Repository)-[:HAS_FILE]->(f:File)
        WHERE id(r) = $repo_id AND ({where_clause})
        RETURN f.path AS path, f.name AS name, f.language AS language,
               f.summary AS summary
        """
        
        results = self.connector.run_query(query, {"repo_id": self.repository_id})
        logger.info(f"Found {len(results)} security-relevant files")
        
        return results
    
    async def _analyze_focus_area(
        self,
        focus_area: str,
        repo_info: Dict[str, Any],
    ) -> None:
        """Analyze a specific security focus area.
        
        Args:
            focus_area: Security focus area to analyze
            repo_info: Repository information
        """
        logger.info(f"Analyzing focus area: {focus_area}")
        
        # Get relevant background knowledge for this focus area
        knowledge = await self._get_focus_area_knowledge(focus_area)
        
        # Get relevant code for this focus area
        relevant_code = await self._get_focus_area_code(focus_area)
        
        # Analyze the focus area using the vulnerability research agent
        analysis_result = await self.agents["vuln_researcher"].analyze_focus_area(
            focus_area=focus_area,
            repository_info=repo_info,
            relevant_code=relevant_code,
            knowledge=knowledge,
        )
        
        # Record the analysis in the investigation
        if self.investigation_id:
            self.connector.run_query(
                "MATCH (i:Investigation) WHERE id(i) = $id "
                "CREATE (a:FocusAreaAnalysis {focus_area: $focus_area, timestamp: $timestamp}) "
                "CREATE (i)-[:HAS_ANALYSIS]->(a)",
                {
                    "id": self.investigation_id,
                    "focus_area": focus_area,
                    "timestamp": datetime.utcnow().isoformat(),
                },
            )
    
    async def _get_focus_area_knowledge(self, focus_area: str) -> List[Dict[str, Any]]:
        """Get knowledge relevant to a specific security focus area.
        
        Args:
            focus_area: Security focus area
            
        Returns:
            List of relevant knowledge items
        """
        # Retrieve knowledge from the knowledge agent
        query = f"security vulnerability {focus_area}"
        knowledge_agent = self.agents["knowledge"]
        results = await knowledge_agent.retrieve_knowledge(query)
        
        logger.info(f"Retrieved {len(results)} knowledge items for focus area: {focus_area}")
        return results
    
    async def _get_focus_area_code(self, focus_area: str) -> List[Dict[str, Any]]:
        """Get code relevant to a specific security focus area.
        
        Args:
            focus_area: Security focus area
            
        Returns:
            List of relevant code snippets
        """
        # Generate a query based on the focus area
        query_terms = {
            "Injection": ["sql", "query", "exec", "eval", "command", "shell", "process.spawn"],
            "Authentication": ["login", "auth", "password", "credential", "session", "token"],
            "Authorization": ["permission", "role", "access", "right", "authorize", "privilege"],
            "Sensitive Data Exposure": ["encrypt", "decrypt", "hash", "password", "key", "secret", "credential"],
            "Security Misconfiguration": ["config", "setup", "environment", "env", "settings"],
            "Input Validation": ["input", "validate", "sanitize", "escape", "parameter"],
            "Error Handling": ["error", "exception", "catch", "try", "handle", "fail"],
            "Cryptographic Issues": ["crypt", "hash", "md5", "sha", "aes", "encrypt", "random", "key"],
        }
        
        # Get search terms for this focus area
        search_terms = query_terms.get(focus_area, [focus_area.lower()])
        
        # Build a combined query
        code_results = []
        for term in search_terms:
            # Get an embedding for the search term
            from ..core.openai_client import get_openai_client
            openai_client = get_openai_client(async_mode=True)
            query = f"code vulnerability {focus_area} {term}"
            embedding = await openai_client.get_embedding(query)
            
            # Search for relevant code files using vector similarity
            query = """
            MATCH (r:Repository)-[:HAS_FILE]->(f:File)-[:HAS_CONTENT]->(c:CodeContent)
            WHERE id(r) = $repo_id AND c.embedding IS NOT NULL
            WITH f, c, vector.similarity(c.embedding, $embedding) AS score
            WHERE score > 0.6
            RETURN f.path AS path, f.language AS language, c.content AS content, score
            ORDER BY score DESC
            LIMIT 5
            """
            
            results = self.connector.run_query(
                query, {"repo_id": self.repository_id, "embedding": embedding}
            )
            
            # Add results to our collection, avoiding duplicates
            existing_paths = {item["path"] for item in code_results}
            for result in results:
                if result["path"] not in existing_paths:
                    code_results.append(result)
                    existing_paths.add(result["path"])
            
            # Stop if we have enough results
            if len(code_results) >= 10:
                break
        
        logger.info(f"Found {len(code_results)} code snippets for focus area: {focus_area}")
        return code_results
    
    async def _generate_report(self) -> Dict[str, Any]:
        """Generate a comprehensive vulnerability assessment report.
        
        Returns:
            Dictionary with the report content
        """
        logger.info("Generating vulnerability assessment report")
        
        # Get repository info
        repo_info = self._get_repository_info()
        
        # Get all findings
        findings = self.findings
        
        # Group findings by severity
        findings_by_severity = {}
        for finding in findings:
            severity = finding.get("severity", "Unknown")
            if severity not in findings_by_severity:
                findings_by_severity[severity] = []
            findings_by_severity[severity].append(finding)
        
        # Generate executive summary using the vulnerability research agent
        summary_prompt = f"""Generate an executive summary for a vulnerability assessment report 
with the following details:

Repository: {repo_info.get('name')}
Total findings: {len(findings)}
Critical findings: {len(findings_by_severity.get('Critical', []))}
High findings: {len(findings_by_severity.get('High', []))}
Medium findings: {len(findings_by_severity.get('Medium', []))}
Low findings: {len(findings_by_severity.get('Low', []))}

The summary should be concise (150-200 words) and highlight the most significant security concerns, 
the overall security posture, and general recommendations.
"""
        
        executive_summary = await self.agents["vuln_researcher"].analyze_text(summary_prompt)
        
        # Generate the report structure
        report = {
            "title": f"Vulnerability Assessment Report: {repo_info.get('name')}",
            "date": datetime.utcnow().isoformat(),
            "repository": repo_info,
            "executive_summary": executive_summary,
            "findings_count": {
                "total": len(findings),
                "by_severity": {
                    severity: len(items)
                    for severity, items in findings_by_severity.items()
                },
            },
            "findings": findings,
        }
        
        # Save the report in the investigation
        if self.investigation_id:
            report_json = json.dumps(report)
            self.connector.run_query(
                "MATCH (i:Investigation) WHERE id(i) = $id "
                "CREATE (r:Report {content: $report, timestamp: $timestamp}) "
                "CREATE (i)-[:HAS_REPORT]->(r)",
                {
                    "id": self.investigation_id,
                    "report": report_json,
                    "timestamp": datetime.utcnow().isoformat(),
                },
            )
        
        return report
    
    def _format_file_list(self, files: List[Dict[str, Any]]) -> str:
        """Format a list of files for inclusion in a prompt.
        
        Args:
            files: List of file dictionaries
            
        Returns:
            Formatted string
        """
        if not files:
            return "No relevant files found."
        
        result = ""
        for i, file in enumerate(files[:10]):  # Limit to 10 files
            path = file.get("path", "Unknown")
            language = file.get("language", "Unknown")
            summary = file.get("summary", "")
            
            result += f"{i+1}. {path} ({language})"
            if summary:
                result += f"\n   Summary: {summary}"
            result += "\n"
        
        if len(files) > 10:
            result += f"... and {len(files) - 10} more files."
        
        return result