"""Context management for workflow integration.

This module implements components for preserving context across workflow transitions,
enabling seamless handoffs between different workflows and persistence of user preferences.
"""

from typing import Any, Dict, List, Optional, Set, Type, TypeVar, Union
import json
import uuid
from datetime import datetime

from ...utils.logging import get_logger
from ...db.neo4j_connector import get_connector
from ..base import Workflow

logger = get_logger(__name__)

# Type variable for workflow types
T = TypeVar("T", bound=Workflow)


class WorkflowContext:
    """Manages context data that persists across workflow transitions.

    This class handles the storage, retrieval, and processing of context data
    that should be preserved when transitioning between different workflows,
    enabling seamless workflow chaining and integration.
    """

    def __init__(
        self,
        context_id: Optional[str] = None,
        repository_id: Optional[str] = None,
        user_id: Optional[str] = None,
        workflow_id: Optional[str] = None,
    ):
        """Initialize a workflow context.

        Args:
            context_id: Optional ID for the context. Autogenerated if not provided.
            repository_id: Optional ID of the repository associated with this context.
            user_id: Optional ID of the user associated with this context.
            workflow_id: Optional ID of the initial workflow for this context.
        """
        self.context_id = context_id or f"ctx-{uuid.uuid4().hex[:8]}"
        self.repository_id = repository_id
        self.user_id = user_id
        self.workflow_id = workflow_id

        # Initialize empty context data
        self._data: Dict[str, Any] = {
            "metadata": {
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat(),
                "context_id": self.context_id,
                "repository_id": self.repository_id,
                "user_id": self.user_id,
                "workflow_id": self.workflow_id,
                "workflow_history": [],
            },
            "user_preferences": {},
            "workflow_data": {},
            "shared_data": {},
            "findings": [],
        }

        # Initialize content serialization handlers
        self._serializers = {
            # Add custom serializers as needed for complex objects
        }

        # Initialize content deserialization handlers
        self._deserializers = {
            # Add custom deserializers as needed for complex objects
        }

    def add_user_preference(self, key: str, value: Any) -> None:
        """Add or update a user preference.

        Args:
            key: The preference key
            value: The preference value
        """
        self._data["user_preferences"][key] = value
        self._update_timestamp()

    def get_user_preference(self, key: str, default: Any = None) -> Any:
        """Get a user preference.

        Args:
            key: The preference key
            default: Default value to return if key doesn't exist

        Returns:
            The preference value or default
        """
        return self._data["user_preferences"].get(key, default)

    def add_workflow_data(self, workflow_id: str, key: str, value: Any) -> None:
        """Add workflow-specific data.

        Args:
            workflow_id: The ID of the workflow
            key: The data key
            value: The data value
        """
        if workflow_id not in self._data["workflow_data"]:
            self._data["workflow_data"][workflow_id] = {}

        self._data["workflow_data"][workflow_id][key] = value
        self._update_timestamp()

    def get_workflow_data(self, workflow_id: str, key: str, default: Any = None) -> Any:
        """Get workflow-specific data.

        Args:
            workflow_id: The ID of the workflow
            key: The data key
            default: Default value to return if key doesn't exist

        Returns:
            The workflow data value or default
        """
        if workflow_id not in self._data["workflow_data"]:
            return default

        return self._data["workflow_data"][workflow_id].get(key, default)

    def add_shared_data(self, key: str, value: Any) -> None:
        """Add shared data accessible to all workflows.

        Args:
            key: The data key
            value: The data value
        """
        self._data["shared_data"][key] = value
        self._update_timestamp()

    def get_shared_data(self, key: str, default: Any = None) -> Any:
        """Get shared data accessible to all workflows.

        Args:
            key: The data key
            default: Default value to return if key doesn't exist

        Returns:
            The shared data value or default
        """
        return self._data["shared_data"].get(key, default)

    def add_finding(self, finding: Dict[str, Any]) -> None:
        """Add a vulnerability finding to the context.

        Args:
            finding: The finding data
        """
        # Store the finding in the findings list
        self._data["findings"].append(finding)
        self._update_timestamp()

    def get_findings(self) -> List[Dict[str, Any]]:
        """Get all findings in the context.

        Returns:
            List of findings
        """
        return self._data["findings"]

    def record_workflow_transition(
        self, from_workflow: str, to_workflow: str, reason: str = ""
    ) -> None:
        """Record a workflow transition in the history.

        Args:
            from_workflow: The source workflow ID
            to_workflow: The destination workflow ID
            reason: Optional reason for the transition
        """
        transition = {
            "timestamp": datetime.now().isoformat(),
            "from": from_workflow,
            "to": to_workflow,
            "reason": reason,
        }

        self._data["metadata"]["workflow_history"].append(transition)
        self._data["metadata"]["workflow_id"] = to_workflow
        self._update_timestamp()

    def _update_timestamp(self) -> None:
        """Update the last modified timestamp."""
        self._data["metadata"]["updated_at"] = datetime.now().isoformat()

    def serialize(self) -> str:
        """Serialize the context data to a JSON string.

        Returns:
            JSON string representation of the context
        """
        # Create a copy of the data for serialization
        serializable_data = self._data.copy()

        # Apply custom serializers for complex objects
        # This can be extended for domain-specific serialization

        return json.dumps(serializable_data)

    @classmethod
    def deserialize(cls, data: str) -> "WorkflowContext":
        """Deserialize context data from a JSON string.

        Args:
            data: JSON string representation of the context

        Returns:
            A WorkflowContext object
        """
        try:
            raw_data = json.loads(data)

            # Extract metadata
            metadata = raw_data.get("metadata", {})
            context_id = metadata.get("context_id")
            repository_id = metadata.get("repository_id")
            user_id = metadata.get("user_id")
            workflow_id = metadata.get("workflow_id")

            # Create a new context instance
            context = cls(
                context_id=context_id,
                repository_id=repository_id,
                user_id=user_id,
                workflow_id=workflow_id,
            )

            # Populate with the deserialized data
            context._data = raw_data

            # Apply custom deserializers for complex objects
            # This can be extended for domain-specific deserialization

            return context
        except json.JSONDecodeError as e:
            logger.error(f"Failed to deserialize context data: {e}")
            raise ValueError(f"Invalid context data format: {e}")

    def save(self) -> bool:
        """Save the context to the database.

        Returns:
            True if successful, False otherwise
        """
        connector = get_connector()
        if not connector:
            logger.error("Cannot save context: database connection failed")
            return False

        # Serialize the context data
        serialized_data = self.serialize()

        # Check if a context record already exists
        query = """
        MATCH (c:WorkflowContext {context_id: $context_id})
        RETURN id(c) as id
        """

        result = connector.run_query(query, {"context_id": self.context_id})

        if result:
            # Update existing context
            node_id = result[0]["id"]
            connector.update_node(
                node_id,
                {
                    "data": serialized_data,
                    "updated_at": self._data["metadata"]["updated_at"],
                },
            )
            logger.debug(f"Updated workflow context {self.context_id}")
        else:
            # Create new context
            props = {
                "context_id": self.context_id,
                "repository_id": self.repository_id,
                "user_id": self.user_id,
                "workflow_id": self.workflow_id,
                "data": serialized_data,
                "created_at": self._data["metadata"]["created_at"],
                "updated_at": self._data["metadata"]["updated_at"],
            }

            connector.create_node("WorkflowContext", props)
            logger.info(f"Created new workflow context {self.context_id}")

        return True

    @classmethod
    def load(cls, context_id: str) -> Optional["WorkflowContext"]:
        """Load a context from the database.

        Args:
            context_id: The ID of the context to load

        Returns:
            The loaded context, or None if not found
        """
        connector = get_connector()
        if not connector:
            logger.error("Cannot load context: database connection failed")
            return None

        query = """
        MATCH (c:WorkflowContext {context_id: $context_id})
        RETURN c.data as data
        """

        result = connector.run_query(query, {"context_id": context_id})

        if not result:
            logger.warning(f"No workflow context found with ID {context_id}")
            return None

        # Deserialize the context data
        try:
            return cls.deserialize(result[0]["data"])
        except ValueError as e:
            logger.error(f"Failed to load workflow context {context_id}: {e}")
            return None


class ContextManager:
    """Manages workflow contexts and transitions.

    This class provides centralized management of workflow contexts,
    enabling context discovery, creation, and sharing across workflows.
    """

    def __init__(self):
        """Initialize the context manager."""
        self._active_contexts: Dict[str, WorkflowContext] = {}

    def create_context(
        self,
        repository_id: Optional[str] = None,
        user_id: Optional[str] = None,
        workflow_id: Optional[str] = None,
        context_id: Optional[str] = None,
    ) -> WorkflowContext:
        """Create a new workflow context.

        Args:
            repository_id: Optional ID of the repository
            user_id: Optional ID of the user
            workflow_id: Optional ID of the initial workflow
            context_id: Optional explicit context ID

        Returns:
            A new WorkflowContext instance
        """
        context = WorkflowContext(
            context_id=context_id,
            repository_id=repository_id,
            user_id=user_id,
            workflow_id=workflow_id,
        )

        # Register the context as active
        self._active_contexts[context.context_id] = context

        return context

    def get_context(self, context_id: str) -> Optional[WorkflowContext]:
        """Get an active context by ID.

        Args:
            context_id: The ID of the context

        Returns:
            The WorkflowContext if found, None otherwise
        """
        # Check if context is already active
        if context_id in self._active_contexts:
            return self._active_contexts[context_id]

        # Try to load from database
        context = WorkflowContext.load(context_id)
        if context:
            # Register as active
            self._active_contexts[context_id] = context

        return context

    def list_contexts(
        self, repository_id: Optional[str] = None, user_id: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """List available contexts matching criteria.

        Args:
            repository_id: Optional repository ID filter
            user_id: Optional user ID filter

        Returns:
            List of context metadata matching the criteria
        """
        connector = get_connector()
        if not connector:
            logger.error("Cannot list contexts: database connection failed")
            return []

        # Build query conditions based on filters
        conditions = []
        params = {}

        if repository_id:
            conditions.append("c.repository_id = $repo_id")
            params["repo_id"] = repository_id

        if user_id:
            conditions.append("c.user_id = $user_id")
            params["user_id"] = user_id

        # Construct the full query
        query = "MATCH (c:WorkflowContext)"
        if conditions:
            query += " WHERE " + " AND ".join(conditions)

        query += """
        RETURN c.context_id as context_id,
               c.repository_id as repository_id,
               c.user_id as user_id,
               c.workflow_id as workflow_id,
               c.created_at as created_at,
               c.updated_at as updated_at
        ORDER BY c.updated_at DESC
        """

        results = connector.run_query(query, params)
        return results or []

    def delete_context(self, context_id: str) -> bool:
        """Delete a context by ID.

        Args:
            context_id: The ID of the context to delete

        Returns:
            True if successful, False otherwise
        """
        # Remove from active contexts if present
        if context_id in self._active_contexts:
            del self._active_contexts[context_id]

        # Delete from database
        connector = get_connector()
        if not connector:
            logger.error("Cannot delete context: database connection failed")
            return False

        query = """
        MATCH (c:WorkflowContext {context_id: $context_id})
        DELETE c
        """

        connector.run_query(query, {"context_id": context_id})
        logger.info(f"Deleted workflow context {context_id}")

        return True

    def save_all_active(self) -> None:
        """Save all active contexts to the database."""
        for context in self._active_contexts.values():
            context.save()

    def transition_workflow(
        self,
        context_id: str,
        from_workflow_id: str,
        to_workflow_id: str,
        reason: str = "",
    ) -> Optional[WorkflowContext]:
        """Record a workflow transition in the context.

        Args:
            context_id: The ID of the context
            from_workflow_id: The source workflow ID
            to_workflow_id: The destination workflow ID
            reason: Optional reason for the transition

        Returns:
            The updated context, or None if context not found
        """
        context = self.get_context(context_id)
        if not context:
            logger.error(f"Cannot transition workflow: context {context_id} not found")
            return None

        context.record_workflow_transition(from_workflow_id, to_workflow_id, reason)
        context.save()

        return context


# Singleton instance
_context_manager = None


def get_context_manager() -> ContextManager:
    """Get the singleton context manager instance.

    Returns:
        The ContextManager instance
    """
    global _context_manager
    if _context_manager is None:
        _context_manager = ContextManager()
    return _context_manager
