"""Exploitation Verification Agent for the Skwaq vulnerability assessment system.

This module defines a specialized workflow agent that can verify whether
discovered vulnerabilities are actually exploitable in practice.
"""

from typing import Dict, List, Any, Optional, Set, Tuple, Union, cast
import asyncio
import json
import enum
import time
import uuid

from ..base import AutogenChatAgent
from ..events import AgentCommunicationEvent, TaskAssignmentEvent, TaskResultEvent, Task
from ...events.system_events import EventBus, SystemEvent
from ...utils.config import get_config
from ...utils.logging import get_logger
from ...shared.finding import Finding

logger = get_logger(__name__)


class ExploitabilityStatus(enum.Enum):
    """Status of exploitation verification."""

    EXPLOITABLE = "exploitable"
    POTENTIALLY_EXPLOITABLE = "potentially_exploitable"
    THEORETICAL = "theoretical"
    NOT_EXPLOITABLE = "not_exploitable"
    INSUFFICIENT_INFORMATION = "insufficient_information"


class ExploitVerificationEvent(SystemEvent):
    """Event for communicating exploitation verification results."""

    def __init__(
        self,
        sender_id: str,
        finding_id: str,
        status: ExploitabilityStatus,
        justification: str,
        exploitation_path: Optional[Dict[str, Any]] = None,
        risk_factors: Optional[Dict[str, Any]] = None,
        verification_id: str = "",
        target: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None,
    ):
        """Initialize an exploitation verification event.

        Args:
            sender_id: ID of the sending agent
            finding_id: ID of the finding being verified
            status: Exploitability status
            justification: Explanation of the verification result
            exploitation_path: Optional step-by-step path to exploitation
            risk_factors: Optional risk factors affecting exploitation
            verification_id: Unique identifier for this verification
            target: Optional target component for the event
            metadata: Additional metadata for the event
        """
        verification_metadata = metadata or {}
        verification_metadata.update(
            {
                "finding_id": finding_id,
                "status": status.value,
                "verification_id": verification_id or str(uuid.uuid4()),
                "event_type": "exploit_verification",
            }
        )

        message = f"Exploitation verification for finding {finding_id}: {status.value}"

        super().__init__(
            sender=sender_id,
            message=message,
            target=target,
            metadata=verification_metadata,
        )
        self.sender_id = sender_id
        self.finding_id = finding_id
        self.status = status
        self.justification = justification
        self.exploitation_path = exploitation_path or {}
        self.risk_factors = risk_factors or {}
        self.verification_id = verification_metadata["verification_id"]


class ExploitationVerificationAgent(AutogenChatAgent):
    """Specialized agent for verifying if vulnerabilities are exploitable in practice.

    This agent analyzes vulnerability findings to determine whether they are
    practically exploitable, providing exploitation paths where possible and
    assessing exploitation difficulty and impact.
    """

    def __init__(
        self,
        name: str = "ExploitationVerificationAgent",
        description: str = "Verifies if vulnerabilities are exploitable in practice",
        config_key: str = "agents.exploitation_verification",
        system_message: Optional[str] = None,
        agent_id: Optional[str] = None,
        model: Optional[str] = None,
    ):
        """Initialize the exploitation verification agent.

        Args:
            name: Name of the agent
            description: Description of the agent's purpose
            config_key: Configuration key for this agent
            system_message: Custom system message for the agent
            agent_id: Optional unique identifier for the agent
            model: Optional model override
        """
        if system_message is None:
            system_message = """You are an Exploitation Verification Agent for a vulnerability assessment system.
Your purpose is to analyze reported vulnerabilities and determine whether
they are actually exploitable in practice, and if so, under what conditions.

Your responsibilities include:
1. Analyzing reported vulnerabilities for practical exploitability
2. Determining the conditions required for successful exploitation
3. Identifying exploitation constraints and prerequisites
4. Assessing the technical difficulty of exploitation
5. Evaluating the impact of successful exploitation
6. Providing detailed exploitation paths where appropriate
7. Assigning an exploitability status to each finding

Your analysis should be technically rigorous, considering both theoretical
and practical aspects of exploitation. For each vulnerability, provide clear
rationale for your exploitability determination, and where applicable, describe
the steps an attacker would need to take to exploit the vulnerability.

Remember that your role is to analyze exploitability objectively - not to
assist in actual exploitation. Your insights will help prioritize vulnerabilities
for remediation based on real-world risk.
"""

        super().__init__(
            name=name,
            description=description,
            config_key=config_key,
            system_message=system_message,
            agent_id=agent_id,
            model=model,
        )

        # Set up verification tracking
        self.verifications: Dict[str, Dict[str, Any]] = {}
        self.verification_tasks: Dict[str, Task] = {}

    async def _start(self):
        """Initialize the agent on startup."""
        await super()._start()

        # Register event handlers
        self.register_event_handler(
            ExploitVerificationEvent, self._handle_verification_event
        )
        self.register_event_handler(TaskAssignmentEvent, self._handle_task_assignment)
        self.register_event_handler(TaskResultEvent, self._handle_task_result)

    async def verify_exploitability(
        self,
        finding: Union[Finding, Dict[str, Any]],
        context: Optional[Dict[str, Any]] = None,
        verification_id: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Verify if a vulnerability finding is exploitable in practice.

        Args:
            finding: The finding to verify (can be Finding object or dict)
            context: Optional additional context about the environment
            verification_id: Optional unique identifier for this verification

        Returns:
            Verification results including exploitability status
        """
        # Generate verification ID if not provided
        verification_id = (
            verification_id or f"exploit_{int(time.time())}_{str(uuid.uuid4())[:8]}"
        )

        # Convert Finding to dict if needed
        if isinstance(finding, Finding):
            finding_dict = finding.to_dict()
            finding_id = finding.file_id
        else:
            finding_dict = finding
            finding_id = finding_dict.get(
                "file_id", finding_dict.get("finding_id", "unknown")
            )

        logger.info(f"Starting exploitation verification for finding: {finding_id}")

        # Create verification task
        verification_task = Task(
            task_id=verification_id,
            task_type="exploit_verification",
            task_description=f"Verify exploitability of {finding_id}",
            task_parameters={"finding_id": finding_id, "context": context or {}},
            priority=3,
            sender_id=self.agent_id,
            receiver_id=self.agent_id,
            status="in_progress",
        )

        self.verification_tasks[verification_id] = verification_task

        try:
            # Prepare the verification record
            verification = {
                "verification_id": verification_id,
                "finding_id": finding_id,
                "finding": finding_dict,
                "context": context or {},
                "timestamp": time.time(),
                "status": None,
                "justification": "",
                "exploitation_path": {},
                "risk_factors": {},
            }

            # Perform the verification analysis
            verification_result = await self._analyze_exploitability(
                finding_dict, context or {}
            )

            # Update the verification with results
            verification.update(verification_result)

            # Store the verification
            self.verifications[verification_id] = verification

            # Update task status
            verification_task.status = "completed"
            verification_task.result = verification

            # Emit verification event
            await self._emit_verification_event(verification)

            logger.info(
                f"Completed exploitation verification with status: {verification['status']}"
            )

            return verification

        except Exception as e:
            logger.error(f"Error verifying exploitability: {e}")
            verification_task.status = "failed"
            verification_task.error = str(e)
            raise

    async def _analyze_exploitability(
        self, finding: Dict[str, Any], context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Analyze a finding to determine its exploitability.

        Args:
            finding: Finding to analyze
            context: Additional context information

        Returns:
            Dictionary with exploitability analysis
        """
        # Prepare prompt for exploitability analysis
        finding_str = json.dumps(finding, indent=2)
        context_str = json.dumps(context, indent=2)

        # Build comprehensive prompt for the LLM
        exploit_prompt = (
            f"I need you to analyze the exploitability of the following vulnerability finding:\n\n"
            f"FINDING:\n{finding_str}\n\n"
            f"CONTEXT:\n{context_str}\n\n"
            f"Please determine if this vulnerability is exploitable in practice, and if so, under "
            f"what conditions. Consider both theoretical and practical aspects of exploitation.\n\n"
            f"For your analysis, provide:\n"
            f"1. An exploitability status (exploitable, potentially_exploitable, theoretical, not_exploitable, insufficient_information)\n"
            f"2. A detailed justification for your determination\n"
            f"3. A step-by-step exploitation path if exploitable\n"
            f"4. Risk factors affecting exploitation (including prerequisites, technical difficulty, attacker capabilities, etc.)\n"
            f"5. Potential impact of successful exploitation\n\n"
            f"Return your analysis in JSON format with the following fields:\n"
            f"- status: One of the exploitability statuses mentioned above\n"
            f"- justification: Your detailed explanation\n"
            f"- exploitation_path: Object with steps for exploitation (if applicable)\n"
            f"- risk_factors: Object with factors affecting exploitability\n"
            f"- impact: Object describing the potential impact\n"
            f"- confidence: Your confidence in this assessment (0.0-1.0)\n"
        )

        # Use the chat model to analyze exploitability
        response = await self.openai_client.create_completion(
            prompt=exploit_prompt,
            model=self.model,
            temperature=0.1,
            max_tokens=2000,
            response_format={"type": "json"},
        )

        # Extract the text response
        response_text = response.get("choices", [{}])[0].get("text", "").strip()

        try:
            # Parse the JSON response
            verification = json.loads(response_text)

            # Ensure all required fields are present
            if "status" not in verification:
                verification["status"] = "insufficient_information"
            if "justification" not in verification:
                verification["justification"] = "No justification provided"
            if "exploitation_path" not in verification:
                verification["exploitation_path"] = {}
            if "risk_factors" not in verification:
                verification["risk_factors"] = {}
            if "impact" not in verification:
                verification["impact"] = {}
            if "confidence" not in verification:
                verification["confidence"] = 0.5

            # Validate exploitability status
            try:
                status = ExploitabilityStatus(verification["status"])
                verification["status"] = status.value
            except ValueError:
                # Default to insufficient information if invalid status
                verification["status"] = (
                    ExploitabilityStatus.INSUFFICIENT_INFORMATION.value
                )

            return verification

        except json.JSONDecodeError:
            logger.error(f"Failed to parse exploitability analysis: {response_text}")
            # Return a default verification on parsing error
            return {
                "status": ExploitabilityStatus.INSUFFICIENT_INFORMATION.value,
                "justification": "Error analyzing finding for exploitability",
                "exploitation_path": {},
                "risk_factors": {},
                "impact": {},
                "confidence": 0.0,
            }

    async def _emit_verification_event(self, verification: Dict[str, Any]) -> None:
        """Emit an exploitation verification event with results.

        Args:
            verification: Verification result to emit
        """
        try:
            # Convert status string to enum if needed
            if isinstance(verification["status"], str):
                try:
                    status = ExploitabilityStatus(verification["status"])
                except ValueError:
                    status = ExploitabilityStatus.INSUFFICIENT_INFORMATION
            else:
                status = verification["status"]

            # Create verification event
            event = ExploitVerificationEvent(
                sender_id=self.agent_id,
                finding_id=verification["finding_id"],
                status=status,
                justification=verification["justification"],
                exploitation_path=verification.get("exploitation_path"),
                risk_factors=verification.get("risk_factors"),
                verification_id=verification["verification_id"],
            )

            # Emit the event
            self.emit_event(event)

        except Exception as e:
            logger.error(f"Error emitting exploitation verification event: {e}")

    async def _handle_verification_event(self, event: ExploitVerificationEvent) -> None:
        """Handle incoming exploitation verification events.

        Args:
            event: Incoming verification event
        """
        # Check if this is the right event type
        if not isinstance(event, ExploitVerificationEvent):
            return

        # Log the received verification
        logger.info(
            f"Received exploitation verification event for finding {event.finding_id} with status {event.status.value}"
        )

        # Store the verification for reference
        self.verifications[event.verification_id] = {
            "verification_id": event.verification_id,
            "finding_id": event.finding_id,
            "status": event.status.value,
            "justification": event.justification,
            "exploitation_path": event.exploitation_path,
            "risk_factors": event.risk_factors,
            "sender_id": event.sender_id,
            "timestamp": time.time(),
        }

    async def _handle_task_assignment(self, event: TaskAssignmentEvent) -> None:
        """Handle task assignment events.

        Args:
            event: Task assignment event
        """
        if event.receiver_id != self.agent_id:
            return

        if event.task_type == "exploit_verification":
            # Extract finding information from task parameters
            params = event.task_parameters
            finding_id = params.get("finding_id")
            finding_data = params.get("finding")
            context = params.get("context", {})

            if not finding_id or not finding_data:
                logger.warning(
                    f"Received exploit verification task without finding data: {event.task_id}"
                )

                # Emit task result with error
                await self._emit_task_result(
                    task_id=event.task_id,
                    sender_id=event.sender_id,
                    status="failed",
                    result={"error": "Missing finding data"},
                )
                return

            # Begin verification process
            try:
                result = await self.verify_exploitability(
                    finding=finding_data, context=context, verification_id=event.task_id
                )

                # Emit task result
                await self._emit_task_result(
                    task_id=event.task_id,
                    sender_id=event.sender_id,
                    status="completed",
                    result=result,
                )

            except Exception as e:
                logger.error(f"Error in exploit verification task: {e}")

                # Emit task result with error
                await self._emit_task_result(
                    task_id=event.task_id,
                    sender_id=event.sender_id,
                    status="failed",
                    result={"error": str(e)},
                )

    async def _emit_task_result(
        self, task_id: str, sender_id: str, status: str, result: Any
    ) -> None:
        """Emit a task result event.

        Args:
            task_id: ID of the task
            sender_id: ID of the sender
            status: Status of the task
            result: Result of the task
        """
        event = TaskResultEvent(
            sender_id=self.agent_id,
            receiver_id=sender_id,
            task_id=task_id,
            status=status,
            result=result,
        )
        self.emit_event(event)

    async def _handle_task_result(self, event: TaskResultEvent) -> None:
        """Handle task result events.

        Args:
            event: Task result event
        """
        # Currently no specific handling needed for task results
        pass

    def get_verification(self, verification_id: str) -> Optional[Dict[str, Any]]:
        """Get a verification result by ID.

        Args:
            verification_id: ID of the verification to retrieve

        Returns:
            Verification result or None if not found
        """
        return self.verifications.get(verification_id)

    def get_verifications_by_finding(self, finding_id: str) -> List[Dict[str, Any]]:
        """Get all verifications for a specific finding.

        Args:
            finding_id: ID of the finding

        Returns:
            List of verification results for the finding
        """
        return [
            v for v in self.verifications.values() if v.get("finding_id") == finding_id
        ]
