# Vulnerability Assessment Copilot - A Multiagent AI System for Aiding in or Learning Vulnerability Discovery

## Overview

The Vulnerability Assessment Copilot, codenamed "skwaq," is an AI-driven multiagent system designed to assist vulnerability researchers in analyzing software codebases to identify potential vulnerabilities. It leverages structured ingestion, semantic indexing, and interactive workflows to facilitate comprehensive vulnerability assessments.

### Project Name: Skwaq

The name "skwaq" comes from the Lushootseed language of the Pacific Northwest and means "Raven." In many Pacific Northwest Indigenous traditions, Raven is a prominent trickster and creator figure who uses wit and cleverness to uncover and exploit hidden things, often revealing secrets or bringing hidden truths to light. This symbolism aligns perfectly with the purpose of this toolâ€”to intelligently discover hidden vulnerabilities and security issues within software codebases.

## System Components

### Interface
The system provides a command-line interface (CLI) built using the [Rich](https://rich.readthedocs.io/en/stable/) library, enabling users to manage ingestion processes, background knowledge, and vulnerability investigation workflows.

### Ingestion
The ingestion process transforms software repositories into structured representations stored in a Neo4J graph database. It includes:

- **Abstract Syntax Tree (AST)**: Captures the syntactic structure of the codebase, facilitating detailed code analysis.
- **File System Tree**: Represents the hierarchical layout of files and directories within the repository.
- **Code Summaries and Developer Intent**: AI-generated summaries documenting the purpose, functionality, and interactions of modules, classes, and subsystems.
- **API Documentation (APIDoc)**: Incorporates available API documentation into the graph for enhanced context.

The ingestion process employs semantic indexing using Neo4J's native vector search capabilities, following methodologies described [here](https://neo4j.com/blog/developer/knowledge-graph-structured-semantic-search/).

### Background Knowledge
The system maintains a separate Neo4J database containing semantic and graph indices of expert knowledge documents, including vulnerability research best practices and the [Common Weakness Enumeration (CWE)](https://cwe.mitre.org/data/downloads.html) database. Users can dynamically update or reinitialize this knowledge base through the CLI.

### Workflows
Post-ingestion, the system supports multiple interactive workflows:

- **Q&A**: Functions as an AI chatbot, answering user queries about the codebase, vulnerabilities, and investigative methods.
- **Guided Inquiry**: Actively engages users by asking targeted questions, updating its internal investigation graph based on user responses, and educating users on potential vulnerabilities.
- **Tool Invocation**: Executes specified vulnerability analysis tools, interprets their outputs, and applies judgment to filter false positives.
- **Vulnerability Research**: Conducts iterative vulnerability assessments, combining user interactions, tool outputs, and background knowledge to produce detailed vulnerability research reports with actionable recommendations.

## Architecture

### Programming Language and Frameworks
The system is implemented in Python and designed to run within a Linux container environment. Dependency management is handled by "uv," while build and linting tasks utilize "poetry/poe." The multiagent architecture is built upon the [AutoGen Core](https://microsoft.github.io/autogen/stable/user-guide/core-user-guide/index.html) framework.

### AI Models Used
Inference tasks exclusively utilize Azure OpenAI models:
- **o3 model**: Code analysis and generation tasks.
- **o1 model**: Logical reasoning and planning tasks.
- **Gpt4o model**: General-purpose inference tasks, including summarization and conversational interactions.

### Azure AI Configuration
The system supports flexible configuration for Azure OpenAI services:
- **Dual Authentication Methods**: Supports both API Key and Microsoft Entra ID (formerly Azure AD) authentication.
- **Environment Variable Configuration**: Automatically loads configurations from environment variables.
- **`.env` File Support**: Falls back to reading configurations from a local `.env` file if environment variables are not set.
- **Interactive Configuration**: If no configuration is found, the CLI and GUI prompt users for necessary configuration details.
- **Configuration Persistence**: Configurations can be saved securely for future sessions.
- **Template Configuration**: A `.env.template` file is provided as a guide for required configuration values.

### Prompt Management
Prompts are managed separately using the Prompty.ai framework, with each prompt stored in dedicated `.prompty` files for modularity and ease of maintenance.

### Local Persistence in Neo4J
The system defaults to a local Neo4J instance but supports configuration for remote Neo4J services. Background knowledge and ingested codebases are stored in separate databases, each employing semantic indexing for efficient retrieval.

### Background Knowledge Initialization
Upon initialization, the system ingests documents from the `data/knowledge` directory, automatically constructing a semantic knowledge graph. Users can dynamically add new documents or reinitialize the entire knowledge graph via CLI commands.

### Code Ingestion Process
Users initiate ingestion via the CLI, specifying either a GitHub repository URL or a local repository path. Additional documentation sources can also be specified. The ingestion process involves:
- Utilizing [blarify](https://github.com/blarApp/blarify/blob/main/docs/quickstart.md) to generate a comprehensive graph representation of the codebase.
- Mapping the filesystem layout into a structured graph.
- Generating detailed summaries for each module, class, subsystem, and the overall codebase, iteratively refining summaries as new insights emerge.
- Incorporating provided API documentation and supplementary documentation into the graph.

### Investigations
Each workflow interaction is recorded as an Investigation within the graph database, linked to the corresponding code ingestion. Investigations capture detailed steps, intermediate results, user interactions, and feedback, providing a comprehensive audit trail.

### Workflows and Events
All system operations, including CLI commands, ingestion steps, and workflow activities, emit structured events defined via Protocol Buffers (.proto files stored in the `/protos` directory). Agents both emit and listen to these events, managed centrally by the AutoGen Core event system.

## Agent Architecture

The system employs specialized AI agents, each with clearly defined responsibilities and event-driven interactions managed by AutoGen Core.

### Agent Memories
Agents maintain working memories within dedicated subgraphs of the Investigation graph, treating the Investigation graph as shared memory. This facilitates coordinated actions and informed decision-making across agents.

### Vulnerability Researcher Copilot (Orchestrator Agent)
The primary orchestrator agent responsible for:
- Managing user interactions via CLI.
- Coordinating ingestion processes and workflows.
- Dispatching tasks to specialized agents.
- Aggregating results and generating comprehensive vulnerability reports.

### Background Knowledge Ingestion Agents
Specialized agents responsible for:
- Parsing and indexing expert knowledge documents.
- Integrating CWE data into the knowledge graph.
- Maintaining semantic indices for efficient retrieval.

### Background Knowledge Retrieval Agents
Agents dedicated to querying and retrieving relevant information from the Background Knowledge graph, supporting other agents during analysis and workflows.

### Code Ingestion Agents
Specialized agents handling distinct ingestion tasks:
- **AST Generation Agent**: Parses code into AST representations.
- **Filesystem Mapping Agent**: Constructs filesystem layout graphs.
- **Code Summarization Agent**: Generates and iteratively refines summaries of modules, classes, subsystems, and overall codebase.
- **Documentation Integration Agent**: Incorporates external documentation into the graph.

### Code Graph Retrieval Agents
Agents tasked with retrieving relevant information from the code ingestion graph and associated investigations, providing context and insights to workflow agents.

### Workflow Agents
Dedicated agents managing specific workflows:
- **Q&A Agent**: Provides interactive query responses about the codebase.
- **Guided Inquiry Agent**: Conducts structured interviews with users, updating investigation graphs accordingly.
- **Tool Invocation Agent**: Executes vulnerability analysis tools, analyzes outputs, and filters false positives.
- **Vulnerability Research Agent**: Performs iterative vulnerability discovery processes, synthesizing findings into comprehensive vulnerability reports.
- **Reporting Agent**: Compiles detailed vulnerability reports, including identified issues, severity ratings, and remediation recommendations.

### Agents within Agents (Subagent Patterns)
Complex agents incorporate specialized subagents for granular tasks:
- **Step-specific Subagents**: Handle discrete tasks within workflows, such as specific vulnerability checks or tool executions.
- **Critic Agents**: Evaluate outputs from other agents, ensuring accuracy, completeness, and relevance. Critic agents emit evaluation events, prompting iterative refinement of results.

### Command Line Interface (CLI)
The CLI, built using the [Rich](https://rich.readthedocs.io/en/stable/) library, provides intuitive commands for:
- Managing code ingestion processes (local or remote repositories).
- Managing background knowledge (adding documents, reinitializing knowledge graphs).
- Initiating and controlling workflows and investigations.
- Viewing investigation progress, results, and agent interactions.

### Security and Compliance
The system adheres to best practices for secure software development, including:
- Secure handling of sensitive data and credentials.
- Compliance with relevant security standards and guidelines.
- Audit logging of all significant actions and events for traceability.

### Extensibility and Customization
The architecture is designed for extensibility:
- Clearly defined agent interfaces and event-driven architecture facilitate adding new agents or workflows.
- Modular prompt management allows easy customization of agent behaviors and responses.
- Configurable ingestion and indexing processes to accommodate diverse codebases and documentation formats.

## Conclusion
The Vulnerability Assessment Copilot provides a robust, extensible, and interactive platform for vulnerability researchers, leveraging advanced AI models, structured knowledge graphs, and a modular multiagent architecture to streamline and enhance vulnerability discovery processes.


