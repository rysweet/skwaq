"""Unit tests for skwaq.security.vulnerability module."""

import json
import os
import datetime
import re
import pytest
from unittest.mock import MagicMock, patch, mock_open
from pathlib import Path

from skwaq.security.vulnerability import (
    VulnerabilityType,
    VulnerabilitySeverity,
    VulnerabilityStatus,
    CVEData,
    CWEData,
    VulnerabilityFinding,
    RemediationAction,
    VulnerabilityManager,
    get_vulnerability_manager,
    add_vulnerability,
    add_remediation,
    complete_remediation,
    get_vulnerability_report,
)


class TestEnums:
    """Tests for the enum classes."""

    def test_vulnerability_type_enum(self):
        """Test VulnerabilityType enum."""
        assert VulnerabilityType.SQL_INJECTION.value == "sql_injection"
        assert VulnerabilityType.XSS.value == "xss"
        assert VulnerabilityType.CSRF.value == "csrf"
        assert VulnerabilityType("sql_injection") == VulnerabilityType.SQL_INJECTION
        assert VulnerabilityType("xss") == VulnerabilityType.XSS

    def test_vulnerability_severity_enum(self):
        """Test VulnerabilitySeverity enum."""
        assert VulnerabilitySeverity.CRITICAL.value == "critical"
        assert VulnerabilitySeverity.HIGH.value == "high"
        assert VulnerabilitySeverity.MEDIUM.value == "medium"
        assert VulnerabilitySeverity.LOW.value == "low"
        assert VulnerabilitySeverity.INFO.value == "info"
        assert VulnerabilitySeverity("critical") == VulnerabilitySeverity.CRITICAL
        assert VulnerabilitySeverity("high") == VulnerabilitySeverity.HIGH

    def test_vulnerability_status_enum(self):
        """Test VulnerabilityStatus enum."""
        assert VulnerabilityStatus.IDENTIFIED.value == "identified"
        assert VulnerabilityStatus.VERIFIED.value == "verified"
        assert VulnerabilityStatus.FALSE_POSITIVE.value == "false_positive"
        assert VulnerabilityStatus.ACCEPTED.value == "accepted"
        assert VulnerabilityStatus.IN_PROGRESS.value == "in_progress"
        assert VulnerabilityStatus.FIXED.value == "fixed"
        assert VulnerabilityStatus.CLOSED.value == "closed"
        assert VulnerabilityStatus("identified") == VulnerabilityStatus.IDENTIFIED
        assert VulnerabilityStatus("verified") == VulnerabilityStatus.VERIFIED


class TestCVEData:
    """Tests for the CVEData class."""

    def test_init(self):
        """Test initialization with required parameters."""
        cve = CVEData(
            cve_id="CVE-2023-12345",
            description="Test CVE description",
            severity=VulnerabilitySeverity.HIGH,
            cvss_score=8.5,
            published_date="2023-01-01T00:00:00",
            last_modified_date="2023-01-15T00:00:00",
        )
        
        assert cve.cve_id == "CVE-2023-12345"
        assert cve.description == "Test CVE description"
        assert cve.severity == VulnerabilitySeverity.HIGH
        assert cve.cvss_score == 8.5
        assert cve.published_date == "2023-01-01T00:00:00"
        assert cve.last_modified_date == "2023-01-15T00:00:00"
        assert isinstance(cve.references, list)
        assert isinstance(cve.cwe_ids, list)
        assert isinstance(cve.vulnerable_configurations, list)
        assert len(cve.references) == 0
        assert len(cve.cwe_ids) == 0
        assert len(cve.vulnerable_configurations) == 0

    def test_init_with_optional_params(self):
        """Test initialization with optional parameters."""
        cve = CVEData(
            cve_id="CVE-2023-12345",
            description="Test CVE description",
            severity=VulnerabilitySeverity.HIGH,
            cvss_score=8.5,
            published_date="2023-01-01T00:00:00",
            last_modified_date="2023-01-15T00:00:00",
            references=["https://example.com/ref1", "https://example.com/ref2"],
            cwe_ids=["CWE-79", "CWE-89"],
            vulnerable_configurations=["cpe:2.3:a:vendor:product:1.0:*:*:*:*:*:*:*"],
        )
        
        assert len(cve.references) == 2
        assert "https://example.com/ref1" in cve.references
        assert len(cve.cwe_ids) == 2
        assert "CWE-79" in cve.cwe_ids
        assert len(cve.vulnerable_configurations) == 1

    def test_to_dict(self):
        """Test to_dict method."""
        cve = CVEData(
            cve_id="CVE-2023-12345",
            description="Test CVE description",
            severity=VulnerabilitySeverity.HIGH,
            cvss_score=8.5,
            published_date="2023-01-01T00:00:00",
            last_modified_date="2023-01-15T00:00:00",
            references=["https://example.com/ref1"],
            cwe_ids=["CWE-79"],
            vulnerable_configurations=["cpe:2.3:a:vendor:product:1.0:*:*:*:*:*:*:*"],
        )
        
        result = cve.to_dict()
        
        assert result["cve_id"] == "CVE-2023-12345"
        assert result["description"] == "Test CVE description"
        assert result["severity"] == "high"
        assert result["cvss_score"] == 8.5
        assert result["published_date"] == "2023-01-01T00:00:00"
        assert result["last_modified_date"] == "2023-01-15T00:00:00"
        assert result["references"] == ["https://example.com/ref1"]
        assert result["cwe_ids"] == ["CWE-79"]
        assert result["vulnerable_configurations"] == ["cpe:2.3:a:vendor:product:1.0:*:*:*:*:*:*:*"]

    def test_from_dict(self):
        """Test from_dict method."""
        data = {
            "cve_id": "CVE-2023-12345",
            "description": "Test CVE description",
            "severity": "medium",
            "cvss_score": 5.5,
            "published_date": "2023-01-01T00:00:00",
            "last_modified_date": "2023-01-15T00:00:00",
            "references": ["https://example.com/ref1"],
            "cwe_ids": ["CWE-79"],
            "vulnerable_configurations": ["cpe:2.3:a:vendor:product:1.0:*:*:*:*:*:*:*"],
        }
        
        cve = CVEData.from_dict(data)
        
        assert cve.cve_id == "CVE-2023-12345"
        assert cve.description == "Test CVE description"
        assert cve.severity == VulnerabilitySeverity.MEDIUM
        assert cve.cvss_score == 5.5
        assert cve.published_date == "2023-01-01T00:00:00"
        assert cve.last_modified_date == "2023-01-15T00:00:00"
        assert cve.references == ["https://example.com/ref1"]
        assert cve.cwe_ids == ["CWE-79"]
        assert cve.vulnerable_configurations == ["cpe:2.3:a:vendor:product:1.0:*:*:*:*:*:*:*"]


class TestCWEData:
    """Tests for the CWEData class."""

    def test_init(self):
        """Test initialization with required parameters."""
        cwe = CWEData(
            cwe_id="CWE-79",
            name="Improper Neutralization of Input During Web Page Generation",
            description="Cross-site Scripting (XSS)",
            extended_description="The software does not neutralize user-controllable input...",
        )
        
        assert cwe.cwe_id == "CWE-79"
        assert cwe.name == "Improper Neutralization of Input During Web Page Generation"
        assert cwe.description == "Cross-site Scripting (XSS)"
        assert cwe.extended_description == "The software does not neutralize user-controllable input..."
        assert cwe.likelihood is None
        assert isinstance(cwe.consequences, list)
        assert isinstance(cwe.mitigations, list)
        assert isinstance(cwe.related_cwe_ids, list)
        assert len(cwe.consequences) == 0
        assert len(cwe.mitigations) == 0
        assert len(cwe.related_cwe_ids) == 0

    def test_init_with_optional_params(self):
        """Test initialization with optional parameters."""
        cwe = CWEData(
            cwe_id="CWE-79",
            name="Improper Neutralization of Input During Web Page Generation",
            description="Cross-site Scripting (XSS)",
            extended_description="The software does not neutralize user-controllable input...",
            likelihood="High",
            consequences=["Information disclosure", "Execute unauthorized code"],
            mitigations=["Use a framework that escapes output by default"],
            related_cwe_ids=["CWE-80", "CWE-83", "CWE-87"],
        )
        
        assert cwe.likelihood == "High"
        assert len(cwe.consequences) == 2
        assert "Information disclosure" in cwe.consequences
        assert len(cwe.mitigations) == 1
        assert len(cwe.related_cwe_ids) == 3
        assert "CWE-80" in cwe.related_cwe_ids

    def test_to_dict(self):
        """Test to_dict method."""
        cwe = CWEData(
            cwe_id="CWE-79",
            name="Improper Neutralization of Input During Web Page Generation",
            description="Cross-site Scripting (XSS)",
            extended_description="The software does not neutralize user-controllable input...",
            likelihood="High",
            consequences=["Information disclosure"],
            mitigations=["Use a framework that escapes output by default"],
            related_cwe_ids=["CWE-80"],
        )
        
        result = cwe.to_dict()
        
        assert result["cwe_id"] == "CWE-79"
        assert result["name"] == "Improper Neutralization of Input During Web Page Generation"
        assert result["description"] == "Cross-site Scripting (XSS)"
        assert result["extended_description"] == "The software does not neutralize user-controllable input..."
        assert result["likelihood"] == "High"
        assert result["consequences"] == ["Information disclosure"]
        assert result["mitigations"] == ["Use a framework that escapes output by default"]
        assert result["related_cwe_ids"] == ["CWE-80"]

    def test_from_dict(self):
        """Test from_dict method."""
        data = {
            "cwe_id": "CWE-89",
            "name": "Improper Neutralization of Special Elements used in an SQL Command",
            "description": "SQL Injection",
            "extended_description": "The software constructs all or part of an SQL command...",
            "likelihood": "High",
            "consequences": ["Data loss", "Data integrity issues"],
            "mitigations": ["Use parameterized queries"],
            "related_cwe_ids": ["CWE-564", "CWE-20"],
        }
        
        cwe = CWEData.from_dict(data)
        
        assert cwe.cwe_id == "CWE-89"
        assert cwe.name == "Improper Neutralization of Special Elements used in an SQL Command"
        assert cwe.description == "SQL Injection"
        assert cwe.extended_description == "The software constructs all or part of an SQL command..."
        assert cwe.likelihood == "High"
        assert cwe.consequences == ["Data loss", "Data integrity issues"]
        assert cwe.mitigations == ["Use parameterized queries"]
        assert cwe.related_cwe_ids == ["CWE-564", "CWE-20"]


class TestVulnerabilityFinding:
    """Tests for the VulnerabilityFinding class."""

    def test_init_required_fields(self):
        """Test initialization with required fields."""
        finding = VulnerabilityFinding(
            title="SQL Injection in Login Form",
            description="The login form is vulnerable to SQL injection",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
        )
        
        assert finding.title == "SQL Injection in Login Form"
        assert finding.description == "The login form is vulnerable to SQL injection"
        assert finding.vulnerability_type == VulnerabilityType.SQL_INJECTION
        assert finding.severity == VulnerabilitySeverity.HIGH
        assert finding.cwe_id is None
        assert finding.cve_id is None
        assert isinstance(finding.affected_components, list)
        assert finding.evidence == ""
        assert finding.remediation == ""
        assert isinstance(finding.references, list)
        assert finding.status == VulnerabilityStatus.IDENTIFIED
        assert finding.confidence == 1.0
        assert isinstance(finding.finding_id, str)
        assert len(finding.finding_id) > 0
        assert isinstance(finding.created_at, datetime.datetime)
        assert isinstance(finding.updated_at, datetime.datetime)
        assert isinstance(finding.metadata, dict)

    def test_init_with_optional_fields(self):
        """Test initialization with optional fields."""
        finding = VulnerabilityFinding(
            title="SQL Injection in Login Form",
            description="The login form is vulnerable to SQL injection",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
            cwe_id="CWE-89",
            cve_id="CVE-2023-12345",
            affected_components=["login", "auth"],
            evidence="SELECT * FROM users WHERE username='{input}'",
            remediation="Use parameterized queries",
            references=["https://example.com/ref1"],
            status=VulnerabilityStatus.VERIFIED,
            confidence=0.9,
            finding_id="test-id-123",
            metadata={"discovered_by": "security_scanner"},
        )
        
        assert finding.cwe_id == "CWE-89"
        assert finding.cve_id == "CVE-2023-12345"
        assert finding.affected_components == ["login", "auth"]
        assert finding.evidence == "SELECT * FROM users WHERE username='{input}'"
        assert finding.remediation == "Use parameterized queries"
        assert finding.references == ["https://example.com/ref1"]
        assert finding.status == VulnerabilityStatus.VERIFIED
        assert finding.confidence == 0.9
        assert finding.finding_id == "test-id-123"
        assert finding.metadata == {"discovered_by": "security_scanner"}

    def test_to_dict(self):
        """Test to_dict method."""
        created_at = datetime.datetime(2023, 1, 1, 12, 0, 0)
        updated_at = datetime.datetime(2023, 1, 2, 12, 0, 0)
        
        finding = VulnerabilityFinding(
            title="XSS in Search Field",
            description="The search field is vulnerable to XSS",
            vulnerability_type=VulnerabilityType.XSS,
            severity=VulnerabilitySeverity.MEDIUM,
            cwe_id="CWE-79",
            finding_id="test-id-456",
            created_at=created_at,
            updated_at=updated_at,
        )
        
        result = finding.to_dict()
        
        assert result["title"] == "XSS in Search Field"
        assert result["description"] == "The search field is vulnerable to XSS"
        assert result["vulnerability_type"] == "xss"
        assert result["severity"] == "medium"
        assert result["cwe_id"] == "CWE-79"
        assert result["finding_id"] == "test-id-456"
        assert result["created_at"] == created_at.isoformat()
        assert result["updated_at"] == updated_at.isoformat()

    def test_from_dict(self):
        """Test from_dict method."""
        data = {
            "title": "CSRF in User Profile",
            "description": "The user profile update is vulnerable to CSRF",
            "vulnerability_type": "csrf",
            "severity": "medium",
            "cwe_id": "CWE-352",
            "evidence": "Form submission without CSRF token",
            "remediation": "Add CSRF tokens to all forms",
            "status": "verified",
            "confidence": 0.85,
            "finding_id": "test-id-789",
            "created_at": "2023-02-01T12:00:00",
            "updated_at": "2023-02-02T12:00:00",
            "metadata": {"test_data": "value"},
        }
        
        finding = VulnerabilityFinding.from_dict(data)
        
        assert finding.title == "CSRF in User Profile"
        assert finding.description == "The user profile update is vulnerable to CSRF"
        assert finding.vulnerability_type == VulnerabilityType.CSRF
        assert finding.severity == VulnerabilitySeverity.MEDIUM
        assert finding.cwe_id == "CWE-352"
        assert finding.evidence == "Form submission without CSRF token"
        assert finding.remediation == "Add CSRF tokens to all forms"
        assert finding.status == VulnerabilityStatus.VERIFIED
        assert finding.confidence == 0.85
        assert finding.finding_id == "test-id-789"
        assert finding.created_at.isoformat() == "2023-02-01T12:00:00"
        assert finding.updated_at.isoformat() == "2023-02-02T12:00:00"
        assert finding.metadata == {"test_data": "value"}


class TestRemediationAction:
    """Tests for the RemediationAction class."""

    def test_init_required_fields(self):
        """Test initialization with required fields."""
        action = RemediationAction(
            description="Implement parameterized queries",
            action_type="code_fix",
        )
        
        assert action.description == "Implement parameterized queries"
        assert action.action_type == "code_fix"
        assert action.assigned_to is None
        assert action.due_date is None
        assert action.status == "open"
        assert action.completed_at is None
        assert action.notes == ""
        assert isinstance(action.action_id, str)
        assert len(action.action_id) > 0
        assert isinstance(action.created_at, datetime.datetime)
        assert isinstance(action.updated_at, datetime.datetime)

    def test_init_with_optional_fields(self):
        """Test initialization with optional fields."""
        due_date = datetime.datetime(2023, 12, 31, 12, 0, 0)
        completed_at = datetime.datetime(2023, 12, 15, 12, 0, 0)
        created_at = datetime.datetime(2023, 11, 1, 12, 0, 0)
        updated_at = datetime.datetime(2023, 12, 16, 12, 0, 0)
        
        action = RemediationAction(
            description="Update framework to the latest version",
            action_type="dependency_update",
            assigned_to="developer1",
            due_date=due_date,
            status="completed",
            completed_at=completed_at,
            notes="Updated to version 2.5.0",
            action_id="action-id-123",
            created_at=created_at,
            updated_at=updated_at,
        )
        
        assert action.description == "Update framework to the latest version"
        assert action.action_type == "dependency_update"
        assert action.assigned_to == "developer1"
        assert action.due_date == due_date
        assert action.status == "completed"
        assert action.completed_at == completed_at
        assert action.notes == "Updated to version 2.5.0"
        assert action.action_id == "action-id-123"
        assert action.created_at == created_at
        assert action.updated_at == updated_at

    def test_to_dict(self):
        """Test to_dict method."""
        due_date = datetime.datetime(2023, 12, 31, 12, 0, 0)
        created_at = datetime.datetime(2023, 11, 1, 12, 0, 0)
        updated_at = datetime.datetime(2023, 11, 2, 12, 0, 0)
        
        action = RemediationAction(
            description="Add input validation",
            action_type="code_fix",
            assigned_to="developer2",
            due_date=due_date,
            action_id="action-id-456",
            created_at=created_at,
            updated_at=updated_at,
        )
        
        result = action.to_dict()
        
        assert result["description"] == "Add input validation"
        assert result["action_type"] == "code_fix"
        assert result["assigned_to"] == "developer2"
        assert result["due_date"] == due_date.isoformat()
        assert result["status"] == "open"
        assert result["completed_at"] is None
        assert result["notes"] == ""
        assert result["action_id"] == "action-id-456"
        assert result["created_at"] == created_at.isoformat()
        assert result["updated_at"] == updated_at.isoformat()

    def test_from_dict(self):
        """Test from_dict method."""
        data = {
            "description": "Configure CSP headers",
            "action_type": "configuration_change",
            "assigned_to": "devops1",
            "due_date": "2023-10-15T12:00:00",
            "status": "in_progress",
            "completed_at": None,
            "notes": "Testing in staging environment",
            "action_id": "action-id-789",
            "created_at": "2023-09-01T12:00:00",
            "updated_at": "2023-09-10T12:00:00",
        }
        
        action = RemediationAction.from_dict(data)
        
        assert action.description == "Configure CSP headers"
        assert action.action_type == "configuration_change"
        assert action.assigned_to == "devops1"
        assert action.due_date.isoformat() == "2023-10-15T12:00:00"
        assert action.status == "in_progress"
        assert action.completed_at is None
        assert action.notes == "Testing in staging environment"
        assert action.action_id == "action-id-789"
        assert action.created_at.isoformat() == "2023-09-01T12:00:00"
        assert action.updated_at.isoformat() == "2023-09-10T12:00:00"


@patch('skwaq.security.vulnerability.get_config')
@patch('skwaq.security.vulnerability.log_security_event')
class TestVulnerabilityManager:
    """Tests for the VulnerabilityManager class."""

    def setup_method(self):
        """Set up test fixture."""
        # Reset the singleton instance before each test
        VulnerabilityManager._instance = None

    def test_singleton_pattern(self, mock_log, mock_get_config):
        """Test the singleton pattern implementation."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        # Create two instances
        manager1 = VulnerabilityManager()
        manager2 = VulnerabilityManager()
        
        # Verify they are the same instance
        assert manager1 is manager2

    @patch('os.makedirs')
    def test_init(self, mock_makedirs, mock_log, mock_get_config):
        """Test initialization."""
        mock_get_config.return_value.get.side_effect = lambda key, default=None: {
            "security.nvd_api_key": "test-api-key",
            "security.findings_dir": "/tmp/findings"
        }.get(key, default)
        
        manager = VulnerabilityManager()
        
        assert manager._initialized is True
        assert manager._findings == {}
        assert manager._remediation_actions == {}
        assert manager._cve_cache == {}
        assert manager._cwe_cache == {}
        assert manager._nvd_api_key == "test-api-key"
        assert manager._findings_dir == Path("/tmp/findings")
        mock_makedirs.assert_called_once_with(Path("/tmp/findings"), exist_ok=True)

    @patch('os.makedirs')
    @patch('builtins.open', new_callable=mock_open)
    @patch('json.load')
    def test_load_cve_cache(self, mock_json_load, mock_file, mock_makedirs, mock_log, mock_get_config):
        """Test loading CVE cache."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        # Setup mock for Path.exists
        with patch.object(Path, 'exists', return_value=True):
            manager = VulnerabilityManager()
            
            # Setup mock for json.load
            mock_json_load.return_value = {
                "CVE-2023-12345": {
                    "cve_id": "CVE-2023-12345",
                    "description": "Test CVE",
                    "severity": "high",
                    "cvss_score": 8.5,
                    "published_date": "2023-01-01T00:00:00",
                    "last_modified_date": "2023-01-15T00:00:00",
                }
            }
            
            # Call _load_cve_cache explicitly to test
            manager._cve_cache = {}
            manager._load_cve_cache()
            
            # Verify cache was loaded
            assert "CVE-2023-12345" in manager._cve_cache
            assert manager._cve_cache["CVE-2023-12345"].cve_id == "CVE-2023-12345"
            assert manager._cve_cache["CVE-2023-12345"].severity == VulnerabilitySeverity.HIGH

    @patch('os.makedirs')
    @patch('builtins.open', new_callable=mock_open)
    @patch('json.dump')
    def test_save_cve_cache(self, mock_json_dump, mock_file, mock_makedirs, mock_log, mock_get_config):
        """Test saving CVE cache."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        manager = VulnerabilityManager()
        
        # Add a CVE to the cache
        cve = CVEData(
            cve_id="CVE-2023-12345",
            description="Test CVE",
            severity=VulnerabilitySeverity.HIGH,
            cvss_score=8.5,
            published_date="2023-01-01T00:00:00",
            last_modified_date="2023-01-15T00:00:00",
        )
        manager._cve_cache["CVE-2023-12345"] = cve
        
        # Call _save_cve_cache
        manager._save_cve_cache()
        
        # Verify file was opened and json.dump was called
        mock_file.assert_called_once()
        mock_json_dump.assert_called_once()
        
        # Get the dumped data
        dumped_data = mock_json_dump.call_args[0][0]
        assert "CVE-2023-12345" in dumped_data
        assert dumped_data["CVE-2023-12345"]["cve_id"] == "CVE-2023-12345"
        assert dumped_data["CVE-2023-12345"]["severity"] == "high"

    @patch('os.makedirs')
    def test_add_finding(self, mock_makedirs, mock_log, mock_get_config):
        """Test adding a vulnerability finding."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        manager = VulnerabilityManager()
        
        # Mock _save_finding method
        manager._save_finding = MagicMock()
        
        # Create a finding
        finding = VulnerabilityFinding(
            title="Test SQL Injection",
            description="Test description",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
            finding_id="test-finding-id"
        )
        
        # Add the finding
        finding_id = manager.add_finding(finding)
        
        # Verify finding was added
        assert finding_id == "test-finding-id"
        assert finding_id in manager._findings
        assert finding_id in manager._remediation_actions
        assert manager._findings[finding_id] == finding
        assert manager._remediation_actions[finding_id] == []
        
        # Verify finding was saved
        manager._save_finding.assert_called_once_with(finding)
        
        # Verify log was called
        mock_log.assert_called_once()

    @patch('os.makedirs')
    def test_update_finding(self, mock_makedirs, mock_log, mock_get_config):
        """Test updating a vulnerability finding."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        manager = VulnerabilityManager()
        
        # Mock _save_finding method
        manager._save_finding = MagicMock()
        
        # Add a finding
        finding = VulnerabilityFinding(
            title="Test SQL Injection",
            description="Test description",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
            finding_id="test-finding-id"
        )
        manager._findings["test-finding-id"] = finding
        
        # Update the finding
        update_result = manager.update_finding("test-finding-id", {
            "title": "Updated Title",
            "severity": "medium",
            "status": "verified"
        })
        
        # Verify update was successful
        assert update_result is True
        assert manager._findings["test-finding-id"].title == "Updated Title"
        assert manager._findings["test-finding-id"].severity == VulnerabilitySeverity.MEDIUM
        assert manager._findings["test-finding-id"].status == VulnerabilityStatus.VERIFIED
        
        # Verify finding was saved
        manager._save_finding.assert_called_once()
        
        # Verify log was called
        mock_log.assert_called_once()
        
        # Test updating non-existent finding
        update_result = manager.update_finding("non-existent-id", {"title": "Test"})
        assert update_result is False

    @patch('os.makedirs')
    def test_get_finding(self, mock_makedirs, mock_log, mock_get_config):
        """Test getting a vulnerability finding."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        manager = VulnerabilityManager()
        
        # Add a finding
        finding = VulnerabilityFinding(
            title="Test SQL Injection",
            description="Test description",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
            finding_id="test-finding-id"
        )
        manager._findings["test-finding-id"] = finding
        
        # Get the finding
        result = manager.get_finding("test-finding-id")
        
        # Verify result
        assert result is finding
        
        # Test with non-existent finding
        manager._load_finding = MagicMock(return_value=None)
        result = manager.get_finding("non-existent-id")
        assert result is None
        
        # Test with finding from disk
        disk_finding = VulnerabilityFinding(
            title="Test from Disk",
            description="Test description",
            vulnerability_type=VulnerabilityType.XSS,
            severity=VulnerabilitySeverity.MEDIUM,
            finding_id="disk-finding-id"
        )
        manager._load_finding = MagicMock(return_value=disk_finding)
        result = manager.get_finding("disk-finding-id")
        assert result is disk_finding
        assert "disk-finding-id" in manager._findings  # Should be cached

    @patch('os.makedirs')
    def test_get_findings(self, mock_makedirs, mock_log, mock_get_config):
        """Test getting multiple vulnerability findings with filters."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        manager = VulnerabilityManager()
        
        # Mock loading all findings
        manager._load_all_findings = MagicMock()
        
        # Add multiple findings
        finding1 = VulnerabilityFinding(
            title="SQL Injection",
            description="Description 1",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
            finding_id="finding-1",
            cwe_id="CWE-89",
            confidence=0.9
        )
        
        finding2 = VulnerabilityFinding(
            title="XSS",
            description="Description 2",
            vulnerability_type=VulnerabilityType.XSS,
            severity=VulnerabilitySeverity.MEDIUM,
            finding_id="finding-2",
            cwe_id="CWE-79",
            confidence=0.8
        )
        
        finding3 = VulnerabilityFinding(
            title="Another SQL Injection",
            description="Description 3",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.CRITICAL,
            finding_id="finding-3",
            cwe_id="CWE-89",
            confidence=0.7
        )
        
        manager._findings = {
            "finding-1": finding1,
            "finding-2": finding2,
            "finding-3": finding3
        }
        
        # Test without filters
        results = manager.get_findings()
        assert len(results) == 3
        
        # Test with vulnerability_type filter
        results = manager.get_findings(vulnerability_type=VulnerabilityType.SQL_INJECTION)
        assert len(results) == 2
        assert all(f.vulnerability_type == VulnerabilityType.SQL_INJECTION for f in results)
        
        # Test with severity filter
        results = manager.get_findings(severity=VulnerabilitySeverity.HIGH)
        assert len(results) == 1
        assert results[0].severity == VulnerabilitySeverity.HIGH
        
        # Test with cwe_id filter
        results = manager.get_findings(cwe_id="CWE-89")
        assert len(results) == 2
        assert all(f.cwe_id == "CWE-89" for f in results)
        
        # Test with confidence_threshold filter
        results = manager.get_findings(confidence_threshold=0.8)
        assert len(results) == 2
        assert all(f.confidence >= 0.8 for f in results)
        
        # Test with multiple filters
        results = manager.get_findings(
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            confidence_threshold=0.8
        )
        assert len(results) == 1
        assert results[0].finding_id == "finding-1"

    @patch('os.makedirs')
    @patch('os.remove')
    def test_delete_finding(self, mock_remove, mock_makedirs, mock_log, mock_get_config):
        """Test deleting a vulnerability finding."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        manager = VulnerabilityManager()
        
        # Add a finding
        finding = VulnerabilityFinding(
            title="Test SQL Injection",
            description="Test description",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
            finding_id="test-finding-id"
        )
        manager._findings["test-finding-id"] = finding
        manager._remediation_actions["test-finding-id"] = []
        
        # Setup mock for Path.exists
        with patch.object(Path, 'exists', return_value=True):
            # Delete the finding
            result = manager.delete_finding("test-finding-id")
            
            # Verify result
            assert result is True
            assert "test-finding-id" not in manager._findings
            assert "test-finding-id" not in manager._remediation_actions
            mock_remove.assert_called_once()
            mock_log.assert_called_once()
            
            # Test deleting non-existent finding
            manager._load_finding = MagicMock(return_value=None)
            result = manager.delete_finding("non-existent-id")
            assert result is False

    @patch('os.makedirs')
    def test_add_remediation_action(self, mock_makedirs, mock_log, mock_get_config):
        """Test adding a remediation action."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        manager = VulnerabilityManager()
        
        # Add a finding
        finding = VulnerabilityFinding(
            title="Test SQL Injection",
            description="Test description",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
            finding_id="test-finding-id"
        )
        manager._findings["test-finding-id"] = finding
        manager._remediation_actions["test-finding-id"] = []
        
        # Mock methods
        manager._save_remediation_action = MagicMock()
        manager.update_finding = MagicMock()
        
        # Create a remediation action
        action = RemediationAction(
            description="Fix SQL Injection",
            action_type="code_fix",
            action_id="test-action-id"
        )
        
        # Add the action
        action_id = manager.add_remediation_action("test-finding-id", action)
        
        # Verify results
        assert action_id == "test-action-id"
        assert len(manager._remediation_actions["test-finding-id"]) == 1
        assert manager._remediation_actions["test-finding-id"][0] == action
        
        # Verify action was saved
        manager._save_remediation_action.assert_called_once_with("test-finding-id", action)
        
        # Verify finding status was updated
        manager.update_finding.assert_called_once_with(
            "test-finding-id", 
            {"status": VulnerabilityStatus.IN_PROGRESS}
        )
        
        # Verify log was called
        mock_log.assert_called_once()
        
        # Test with non-existent finding
        manager.get_finding = MagicMock(return_value=None)
        result = manager.add_remediation_action("non-existent-id", action)
        assert result is None

    @patch('os.makedirs')
    def test_update_remediation_action(self, mock_makedirs, mock_log, mock_get_config):
        """Test updating a remediation action."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        manager = VulnerabilityManager()
        
        # Add a finding and action
        finding = VulnerabilityFinding(
            title="Test SQL Injection",
            description="Test description",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
            finding_id="test-finding-id"
        )
        action = RemediationAction(
            description="Fix SQL Injection",
            action_type="code_fix",
            action_id="test-action-id"
        )
        manager._findings["test-finding-id"] = finding
        manager._remediation_actions["test-finding-id"] = [action]
        
        # Mock methods
        manager._save_remediation_action = MagicMock()
        manager.update_finding = MagicMock()
        
        # Update the action
        result = manager.update_remediation_action(
            "test-finding-id",
            "test-action-id",
            {
                "status": "completed",
                "notes": "Fixed in PR #123"
            }
        )
        
        # Verify results
        assert result is True
        assert manager._remediation_actions["test-finding-id"][0].status == "completed"
        assert manager._remediation_actions["test-finding-id"][0].notes == "Fixed in PR #123"
        assert manager._remediation_actions["test-finding-id"][0].completed_at is not None
        
        # Verify action was saved
        manager._save_remediation_action.assert_called_once()
        
        # Verify finding status was updated to FIXED
        manager.update_finding.assert_called_once_with(
            "test-finding-id", 
            {"status": VulnerabilityStatus.FIXED}
        )
        
        # Verify log was called
        mock_log.assert_called_once()
        
        # Test with non-existent finding
        result = manager.update_remediation_action(
            "non-existent-id",
            "test-action-id",
            {"status": "completed"}
        )
        assert result is False
        
        # Test with non-existent action
        result = manager.update_remediation_action(
            "test-finding-id",
            "non-existent-action-id",
            {"status": "completed"}
        )
        assert result is False

    @patch('os.makedirs')
    def test_generate_report(self, mock_makedirs, mock_log, mock_get_config):
        """Test generating a vulnerability report."""
        mock_get_config.return_value.get.return_value = "/tmp/findings"
        
        manager = VulnerabilityManager()
        
        # Add multiple findings
        finding1 = VulnerabilityFinding(
            title="SQL Injection",
            description="Description 1",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.HIGH,
            finding_id="finding-1"
        )
        
        finding2 = VulnerabilityFinding(
            title="XSS",
            description="Description 2",
            vulnerability_type=VulnerabilityType.XSS,
            severity=VulnerabilitySeverity.MEDIUM,
            finding_id="finding-2"
        )
        
        finding3 = VulnerabilityFinding(
            title="Another SQL Injection",
            description="Description 3",
            vulnerability_type=VulnerabilityType.SQL_INJECTION,
            severity=VulnerabilitySeverity.CRITICAL,
            finding_id="finding-3"
        )
        
        findings = [finding1, finding2, finding3]
        
        # Generate report
        report = manager.generate_report(findings=findings)
        
        # Verify report structure
        assert "title" in report
        assert "date" in report
        assert "summary" in report
        assert "findings" in report
        
        # Verify summary data
        summary = report["summary"]
        assert summary["total_findings"] == 3
        assert summary["severity_distribution"]["high"] == 1
        assert summary["severity_distribution"]["medium"] == 1
        assert summary["severity_distribution"]["critical"] == 1
        assert summary["type_distribution"]["sql_injection"] == 2
        assert summary["type_distribution"]["xss"] == 1
        
        # Verify findings data
        report_findings = report["findings"]
        assert len(report_findings) == 3
        
        # Test without specifying findings
        manager.get_findings = MagicMock(return_value=findings)
        report = manager.generate_report()
        assert len(report["findings"]) == 3


@patch('skwaq.security.vulnerability.VulnerabilityManager')
def test_get_vulnerability_manager(mock_manager_class):
    """Test the get_vulnerability_manager function."""
    # Set up the mock
    mock_instance = MagicMock()
    mock_manager_class.return_value = mock_instance
    
    # Call the function
    manager = get_vulnerability_manager()
    
    # Verify the result
    assert manager == mock_instance
    mock_manager_class.assert_called_once()


@patch('skwaq.security.vulnerability.get_vulnerability_manager')
def test_add_vulnerability(mock_get_manager):
    """Test the add_vulnerability helper function."""
    # Set up the mock
    mock_manager = MagicMock()
    mock_manager.add_finding.return_value = "new-finding-id"
    mock_get_manager.return_value = mock_manager
    
    # Call the function
    finding_id = add_vulnerability(
        title="Test XSS",
        description="Test description",
        vulnerability_type="xss",
        severity="high",
        cwe_id="CWE-79",
        evidence="<script>alert(1)</script>",
        remediation="Sanitize user input"
    )
    
    # Verify the result
    assert finding_id == "new-finding-id"
    
    # Verify the manager's add_finding method was called
    mock_manager.add_finding.assert_called_once()
    
    # Verify the finding passed to add_finding
    finding = mock_manager.add_finding.call_args[0][0]
    assert finding.title == "Test XSS"
    assert finding.description == "Test description"
    assert finding.vulnerability_type == VulnerabilityType.XSS
    assert finding.severity == VulnerabilitySeverity.HIGH
    assert finding.cwe_id == "CWE-79"
    assert finding.evidence == "<script>alert(1)</script>"
    assert finding.remediation == "Sanitize user input"


@patch('skwaq.security.vulnerability.get_vulnerability_manager')
def test_add_remediation(mock_get_manager):
    """Test the add_remediation helper function."""
    # Set up the mock
    mock_manager = MagicMock()
    mock_manager.add_remediation_action.return_value = "new-action-id"
    mock_get_manager.return_value = mock_manager
    
    # Call the function
    action_id = add_remediation(
        finding_id="test-finding-id",
        description="Update framework",
        action_type="dependency_update",
        assigned_to="developer1"
    )
    
    # Verify the result
    assert action_id == "new-action-id"
    
    # Verify the manager's add_remediation_action method was called
    mock_manager.add_remediation_action.assert_called_once()
    
    # Verify the action passed to add_remediation_action
    finding_id = mock_manager.add_remediation_action.call_args[0][0]
    action = mock_manager.add_remediation_action.call_args[0][1]
    assert finding_id == "test-finding-id"
    assert action.description == "Update framework"
    assert action.action_type == "dependency_update"
    assert action.assigned_to == "developer1"
    assert action.status == "open"


@patch('skwaq.security.vulnerability.get_vulnerability_manager')
def test_complete_remediation(mock_get_manager):
    """Test the complete_remediation helper function."""
    # Set up the mock
    mock_manager = MagicMock()
    mock_manager.update_remediation_action.return_value = True
    mock_get_manager.return_value = mock_manager
    
    # Call the function
    result = complete_remediation(
        finding_id="test-finding-id",
        action_id="test-action-id",
        notes="Fixed in commit abc123"
    )
    
    # Verify the result
    assert result is True
    
    # Verify the manager's update_remediation_action method was called
    mock_manager.update_remediation_action.assert_called_once()
    
    # Verify the arguments passed to update_remediation_action
    args = mock_manager.update_remediation_action.call_args[0]
    kwargs = mock_manager.update_remediation_action.call_args[0][2]
    assert args[0] == "test-finding-id"
    assert args[1] == "test-action-id"
    assert kwargs["status"] == "completed"
    assert isinstance(kwargs["completed_at"], datetime.datetime)
    assert kwargs["notes"] == "Fixed in commit abc123"


@patch('skwaq.security.vulnerability.get_vulnerability_manager')
def test_get_vulnerability_report(mock_get_manager):
    """Test the get_vulnerability_report helper function."""
    # Set up the mock
    mock_manager = MagicMock()
    mock_report = {
        "title": "Vulnerability Assessment Report",
        "date": "2023-01-01T00:00:00",
        "summary": {
            "total_findings": 5,
            "risk_score": 42.5
        },
        "findings": []
    }
    mock_manager.generate_report.return_value = mock_report
    mock_get_manager.return_value = mock_manager
    
    # Call the function
    report = get_vulnerability_report()
    
    # Verify the result
    assert report == mock_report
    
    # Verify the manager's generate_report method was called
    mock_manager.generate_report.assert_called_once_with()